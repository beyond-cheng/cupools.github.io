<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Vue 的其他实践 · 一环的笔记</title><meta name="description" content="Vue 的其他实践 - liyh"><meta name="description" content="之前基于 Vue 的项目花了十个工作日不到的时间搞定了二期迭代，又发现了一些实用的东西，于是简单记录一下。">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue 的其他实践">
<meta property="og:url" content="http://cupools.github.io/2016/09120/index.html">
<meta property="og:site_name" content="一环的笔记">
<meta property="og:description" content="之前基于 Vue 的项目花了十个工作日不到的时间搞定了二期迭代，又发现了一些实用的东西，于是简单记录一下。">
<meta property="og:updated_time" content="2016-09-13T01:35:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue 的其他实践">
<meta name="twitter:description" content="之前基于 Vue 的项目花了十个工作日不到的时间搞定了二期迭代，又发现了一些实用的东西，于是简单记录一下。"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://cupools.github.io/atom.xml" title="一环的笔记"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/archives/" target="" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="https://github.com/cupools" target="_blank" class="nav-list-link">GitHub</a></li><li class="nav-list-item"><a href="mailto:cupools@gmail.com" target="" class="nav-list-link">Gmail</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Vue 的其他实践</h1><div class="post-info">Sep 12, 2016<ul class="post-tag-list"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Vue/">Vue</a></li></ul></div><div class="post-content"><p>之前基于 Vue 的项目花了十个工作日不到的时间搞定了二期迭代，又发现了一些实用的东西，于是简单记录一下。</p>
<a id="more"></a>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><blockquote>
<p>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be “mixed” into the component’s own options.</p>
</blockquote>
<p>如文档介绍，混合以一种灵活的方式为组件提供分布复用功能（即将功能从组件中分离，并允许多个组件复用）。这里倾向于逻辑而非模板的复用，同时也区别于插件，更多地与业务相关。</p>
<p>混合的使用很简单，但在使用过程中也需要注意一些地方。一开始自己的使用如下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// define a mixin object</span></div><div class="line"><span class="keyword">var</span> myMixin = &#123;</div><div class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.hello()</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// define a component that uses this mixin</span></div><div class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</div><div class="line">  mixins: [myMixin],</div><div class="line">  data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      foo: <span class="string">'bad code'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> Component() <span class="comment">// -&gt; "bad code"</span></div></pre></td></tr></table></figure>
<p>可以看到混合选项中的方法调用了组件的 data。尽管代码正常运行，但这种做法造成代码的可维护性和可读性比较糟糕。一方面，使用混合的组件必须声明 <code>foo</code>，增加了维护的成本；另一方面对于混合选项来说，<code>foo</code> 这个属性是未知的，可读性很差。我自己的解决方法则是对于组件不关心的属性直接在混合选项中声明，组件关心的属性则组件和混合选项同时声明，由组件的值覆盖后者。</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>这里以 Modal 为例巴拉下自己做法转变的过程。超简化的 Modal 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Modal.vue</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    data() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            visible: <span class="literal">false</span>,</div><div class="line">            msg: <span class="string">''</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        show() &#123;&#125;,</div><div class="line">        hide() &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="组件传递"><a href="#组件传递" class="headerlink" title="组件传递"></a>组件传递</h3><p>每个页面都拥有自己的子组件 Modal 这种事情我不干，高度可定制的内容通过 <code>partial</code> 解决。Modal 组件放在根组件下，通过 <code>prop</code> 直接传给子组件调用。大概这样子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 根组件模板 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:modal</span>=<span class="string">"$refs.modal"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-ref:modal</span>&gt;</span><span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 子组件调用 Modal</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    props: &#123;</div><div class="line">        modal: [<span class="string">'modal'</span>]</div><div class="line">    &#125;,</div><div class="line">    attached() &#123;</div><div class="line">        <span class="keyword">this</span>.modal.show(<span class="string">'hello'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种做法当组件层级复杂的话，需要把 Modal 一层一层传下去。尽管组件的层级关系清晰，但这是比较繁琐的事情。</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>既然不把组件从上往下传，那就可以考虑从下往上把事件抛出来。Vue 的每个实例提供了自定义事件接口，能够抛出事件并被其他组件捕获。于是基于自定义事件调起 Modal 的做法可以如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 根组件模板 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Modal</span> <span class="attr">v-ref:modal</span>&gt;</span><span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 根组件监听事件</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    events: &#123;</div><div class="line">        <span class="string">'modal_show'</span>(...args) &#123;</div><div class="line">            <span class="keyword">this</span>.$refs.modal.show(...args)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 子组件调用 Modal</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    attached() &#123;</div><div class="line">        <span class="keyword">this</span>.$dispatch(<span class="string">'modal_show'</span>, <span class="string">'hello'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义事件使得组件之间很方便进行通信，但是滥用自定义事件的话会造成组件松散，导致难以维护。</p>
<h3 id="基于-Vuex"><a href="#基于-Vuex" class="headerlink" title="基于 Vuex"></a>基于 Vuex</h3><p>把 Modal 的状态放进 <code>store</code> 之后，可以通过 <code>action</code> 很直观地调用 Modal。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// store.js</span></div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line">    modal: &#123;</div><div class="line">        visible: <span class="literal">false</span>,</div><div class="line">        msg: <span class="string">''</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Modal.vue</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    vuex: &#123;</div><div class="line">        getters: &#123;</div><div class="line">            visible: state =&gt; state.modal.visible,</div><div class="line">            msg: state =&gt; state.modal.msg</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">        show() &#123;&#125;,</div><div class="line">        hide() &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 子组件调用 Modal</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    vuex: &#123;</div><div class="line">        actions: &#123;</div><div class="line">            showModal</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    attached: &#123;</div><div class="line">        <span class="keyword">this</span>.showModal(<span class="string">'hello'</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Modal 可以看作整个应用的一个公共状态（等待用户操作），因此把它放进 <code>store</code> 是合理的，然后就是 Vuex 的套路了。</p>
<p>以上三种做法都可以达到目的，当然也有其他做法，看个人想法咯。</p>
<h2 id="服务端同步数据"><a href="#服务端同步数据" class="headerlink" title="服务端同步数据"></a>服务端同步数据</h2><p>之前的做法是在 <code>plugin</code> 中捕获 <code>action</code> 之后发起请求，现在想想这种做法太绕啦，直接在 <code>action</code> 中发起请求更加简洁，然后再 <code>dispatch</code> 服务端响应的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// actions.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchUser = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;dispatch&#125;</span>) </span>&#123;</div><div class="line">    Vue</div><div class="line">        .http()</div><div class="line">        .post(<span class="string">'url'</span>)</div><div class="line">        .then(res =&gt; &#123;</div><div class="line">            <span class="keyword">let</span> ret = res.json()</div><div class="line">            dispatch(ActionTypes.USER_UPDATE, ret.data)</div><div class="line">        &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，上面的做法相当于把服务端同步下来的数据直接放进 store 里面了。如果是组件私有的数据，则可以通过 <code>Mixins</code> 抽象同步数据的方法。上面也提到了，通过混合可以灵活地复用功能。以列表为例，同步服务端可以这样子处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// mixin-list.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    data: &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            _store: [],</div><div class="line">            _params: &#123;&#125;,</div><div class="line">            _link: <span class="string">''</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods() &#123;</div><div class="line">        fetchList() &#123;</div><div class="line">            <span class="keyword">let</span> &#123;_store, _link, _params&#125; = <span class="keyword">this</span>.$data</div><div class="line">            </div><div class="line">            <span class="keyword">this</span></div><div class="line">                .$http()</div><div class="line">                .post(_link, _params)</div><div class="line">                .then(res =&gt; &#123;</div><div class="line">                    <span class="keyword">let</span> ret = res.json()</div><div class="line">                    _store.push(ret.data)</div><div class="line">                &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 组件</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    mixins: [mixinList],</div><div class="line">    data() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            _store: [],</div><div class="line">            _params: &#123;</div><div class="line">                auth: <span class="literal">true</span></div><div class="line">            &#125;,</div><div class="line">            _link: <span class="string">'url'</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">        list() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._store.filter(item =&gt; item.valid)</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    attached() &#123;</div><div class="line">        <span class="keyword">this</span>.fetchList()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/10130/" class="prev">PREV</a><a href="/2016/08260/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2017 <a href="http://cupools.github.io">liyh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-67000695-1",'auto');ga('send','pageview');</script></body></html>