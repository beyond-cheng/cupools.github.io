<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>深入浅出NodeJS | (&lt;ゝω·)Kira☆~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="很厉害的一本书，从其中几个模块的实现和解决思路中学到了很多东西；http 协议方面的东西也在这本书上面恶补了一番，很充实。终于吃完了，吃的很饱撒花哗啦啦

模块机制CommonJS 规范模块引用var math = require(&apos;math&apos;);
CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出NodeJS">
<meta property="og:url" content="http://cupools.github.io/cif86yq60001ctuqcwqkl3ico/index.html">
<meta property="og:site_name" content="(<ゝω·)Kira☆~">
<meta property="og:description" content="很厉害的一本书，从其中几个模块的实现和解决思路中学到了很多东西；http 协议方面的东西也在这本书上面恶补了一番，很充实。终于吃完了，吃的很饱撒花哗啦啦

模块机制CommonJS 规范模块引用var math = require(&apos;math&apos;);
CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文">
<meta property="og:image" content="http://cupools.github.io/images/59-3-13.png">
<meta property="og:image" content="http://cupools.github.io/images/61-3-14.png">
<meta property="og:image" content="http://cupools.github.io/images/168-7-7.png">
<meta property="og:updated_time" content="2015-09-09T08:49:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入浅出NodeJS">
<meta name="twitter:description" content="很厉害的一本书，从其中几个模块的实现和解决思路中学到了很多东西；http 协议方面的东西也在这本书上面恶补了一番，很充实。终于吃完了，吃的很饱撒花哗啦啦

模块机制CommonJS 规范模块引用var math = require(&apos;math&apos;);
CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文">
  
    <link rel="alternative" href="/atom.xml" title="(&lt;ゝω·)Kira☆~" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<!-- <img lazy-src="/img/avatar.jpg" class="js-avatar"> -->
			<img src="/img/avatar.jpg" class="js-avatar show" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">liyh</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">笔记</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cupools" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:cupools@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Javascript/" style="font-size: 20px;">Javascript</a> <a href="/tags/Wordpress/" style="font-size: 10px;">Wordpress</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/学习/" style="font-size: 12.5px;">学习</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/碎屑/" style="font-size: 10px;">碎屑</a> <a href="/tags/读书笔记/" style="font-size: 17.5px;">读书笔记</a> <a href="/tags/配置/" style="font-size: 10px;">配置</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">在校学生，连滚带爬啃书</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">liyh</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/avatar.jpg" class="js-avatar show" style="width: 100%;height: 100%;opacity: 1;">
			</div>
			<hgroup>
			  <h1 class="header-author">liyh</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">笔记</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cupools" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:cupools@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-books/深入浅出NodeJS" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/cif86yq60001ctuqcwqkl3ico/" class="article-date">
  	<time datetime="2015-08-09T16:00:00.000Z" itemprop="datePublished">2015-08-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入浅出NodeJS
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>很厉害的一本书，从其中几个模块的实现和解决思路中学到了很多东西；http 协议方面的东西也在这本书上面恶补了一番，很充实。终于吃完了，吃的很饱撒花哗啦啦</p>
</blockquote>
<h2 id="模块机制">模块机制</h2><h3 id="CommonJS_规范">CommonJS 规范</h3><h4 id="模块引用">模块引用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure>
<p>CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文</p>
<a id="more"></a>
<h4 id="模块定义">模块定义</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">arguments</span>[i]) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块中，上下文提供 require() 方法引入外部模块，提供 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。模块存在一个 module 对象，代表模块本身，而 exports 对象是 module 的属性。在 Node 中，一个文件就是一个模块</p>
<h3 id="Node_的模块实现">Node 的模块实现</h3><p>Node 中引入模块经历的步骤如下：路径分析 =&gt; 文件定位 =&gt; 编译执行。其中，核心模块部分在 Node 源代码编译过程中，编译进了二进制执行文件，在 Node 进程启动时直接加载进内存中，只需要路径分析，并且在路径分析中优先判断</p>
<ul>
<li>优先从缓存加载</li>
<li>核心模块、路径形式的文件模块、自定义模块  <ul>
<li>Node 提供的模块属于核心模块</li>
<li>用户编写的模块属于文件模块。以<code>.</code>、<code>..</code>、<code>/</code>开始的标识符，被当做文件模块处理</li>
<li>自定义模块指的是非核心模块，也不是路径形式的标识符。可能是一个文件或者包的形式。沿路径向上逐级递归，直到根目录下的 node_module 目录为止，查找最费时</li>
</ul>
</li>
<li>文件定位，按 .js、.json、.node 的次序补足扩展名，依次尝试</li>
<li>目录分析和包，Node 在自定义模块目录下查找 package.json，通过<code>JSON.parse</code>解析，并取出 main 属性制定的文件名进行定位。如果没有 package.json，将依次查找 index.js、index.json、index.node</li>
<li>模块编译 TODO</li>
</ul>
<h3 id="包与NPM">包与NPM</h3><p>NPM 是 CommonJS 包规范理论的实践。符合 CommonJS 规范的包目录包含如下文件：</p>
<ul>
<li>package.json：包描述文件</li>
<li>bin：用于存放可执行二进制文件的目录</li>
<li>lib：用于存放 Javascript 代码的目录</li>
<li>doc：用于存放文档的目录</li>
<li>test：用于存放单元测试用例的代码</li>
</ul>
<h4 id="安装依赖包">安装依赖包</h4><ul>
<li><p>全局模式安装，是将一个包安装为全局可用的可执行命令。它根据包描述文件中的 bin 字段配置，将实际脚本链接到 Node 可执行文件相同的可执行路径下</p>
<p>  全局安装的模块包都被安装进一个统一的目录下，通过如下方式推算出来</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.resolve(process.execPath, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'lib'</span>, <span class="string">'node_module'</span>);</span><br></pre></td></tr></table></figure>
<p>  即 Node 可执行文件的位置是<code>/usr/local/bin/node</code>，则模块目录为 <code>/usr/local/lib/node_module</code></p>
</li>
<li><p>本地安装，只需要为 NPM 指明 package.json 文件所在位置即可，可以是一个包含 package.json 的存档文件，也可以是一个 URL 地址，也可以是一个目录下 package.json 文件的目录位置</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &lt;tarball file&gt;</span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从非官方源安装</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install undescore --registry=http://registry.url</span><br></pre></td></tr></table></figure>
<p>  使用过程都使用镜像源安装</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry http://registry.url</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="异步I/O">异步I/O</h2><h3 id="Node_的异步I/O">Node 的异步I/O</h3><h4 id="事件循环">事件循环</h4><p>Node 进程启动时，会启动一个循环，每执行一次循环称为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程</p>
<p>事件循环是一个典型的生产者 / 消费者模型。异步 I/O、网络请求等则是事件的生产者，为 Node 提供不同类型的事件，这些事件被传递到对应的观察者，事件循环则从观察者那里取出事件并做处理</p>
<h4 id="请求对象">请求对象</h4><p>从 Javascript 调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，这是 Node 里经典的调用方式。这里 libuv 作为封装层，有两个平台的实现。调用过程中会创建一个请求对象并推入线程池中等待执行。不管当前的 I/O 操作是否阻塞 I/O，都不会影响到 Javascript 线程的后续执行</p>
<h4 id="执行回调">执行回调</h4><p>组装好请求对象、送入 I/O 线程池等待执行，实际上完成了异步 I/O 的第一部分，回调通知是第二部分。在线程池中的 I/O 操作调用完毕之后，会储存获取的结果然后通知 IOCP，告知当前对象操作已经完成</p>
<p><img src="/images/59-3-13.png" alt="异步 I/O 流程"></p>
<p>事件循环、观察者、请求对象、I/O 线程池这四者共同构成了 Node 异步 I/O 模型的基本要素</p>
<p>Windows 下主要通过 IOCP 来向系统内核发送 I/O 调用和从内核获取已完成的 I/O 操作，配以事件循环，以此完成异步 I/O 的过程。在 Linux 下通过 epoll 实现这个过程，FreeBSD 下通过 kqueue 实现，Solaris 下通过 Event ports 实现。不同的是线程池在 Windows 下由内核（IOCP）直接提供，*nix 系列下由 libuv 自行实现</p>
<h4 id="小结">小结</h4><p>在 Node 中，除了 Javascript 是单线程外，Node 自身是多线程，只是 I/O 线程使用的 CPU 较少。另一个观点是，除了用户代码无法并行执行外，所有的 I/O 则是并行起来的</p>
<h3 id="非_I/O_的异步_API">非 I/O 的异步 API</h3><h4 id="定时器">定时器</h4><p>setTimeout() 和 setInterval() 与浏览器中的 API 是一致的。它们的实现原理与异步 I/O 类似，只是不需要 I/O 线程池的参与。创建的计时器会被插入到定时器观察者内部的一个红黑树中，每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将会立即执行</p>
<p>定时器的问题并不精确，例如通过计时器设定一个任务在10毫秒后执行，但在9毫秒后，有一个任务占用了5毫秒的 CPU 时间片，再次轮到定时器执行时，时间就已经过期4毫秒了</p>
<p><img src="/images/61-3-14.png" alt="setTimeout() 的行为"></p>
<h4 id="process-nextTick()">process.nextTick()</h4><p>采用定时器需要动用红黑树，创建定时器对象和迭代等操作。相比执行，process.nextTick() 方法的操作相对较为轻量。每次调用 process.nextTick() 方法，只会将回调函数放入队列中，在下一轮 Tick 时取出执行。定时器中采用红黑树的操作时间复杂度为 O(lg(n))，nextTick() 的时间复杂度为 O(1)</p>
<h4 id="setImmediate()">setImmediate()</h4><p>process.nextTick() 中的回调函数执行的优先级高于 setImmediate()，原因在于事件循环对观察者的检查有先后顺序。process.nextTick() 属于 idle 观察者，setImmediate() 属于 check 观察者。在每一轮循环检查中，idle 观察者优先于 I/O 观察者，I/O 观察者优先于 check 观察者</p>
<h3 id="事件驱动与高性能服务器">事件驱动与高性能服务器</h3><p>几种经典的服务器模型</p>
<ul>
<li>同步式。对于同步式的服务，一次只能主力一个请求，并且其余请求都处于等待状态</li>
<li>每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多</li>
<li>每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程轻量，但是每个线程都占用一定内存，大并发请求来时，内存会很快耗光</li>
</ul>
<p>Node 通过事件驱动的方式处理请求，无需为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销</p>
<h2 id="异步编程">异步编程</h2><h3 id="异步编程难点">异步编程难点</h3><ul>
<li>异常处理</li>
<li>函数嵌套过深</li>
<li>阻塞代码</li>
<li>多线程编程</li>
<li>异步转同步</li>
</ul>
<h3 id="异步解决方案">异步解决方案</h3><ul>
<li>事件发布 / 订阅模式</li>
<li>Promise / Deferred 模式</li>
<li>流程控制库</li>
</ul>
<h4 id="时间发布/订阅模式">时间发布/订阅模式</h4><p>订阅事件是一个高阶函数的应用。事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。从另一个角度看，事件侦听器模式也是一种钩子机制，利用钩子导出内部数据或状态给外部的调用者</p>
<p>Node 对事件发布/订阅的机制做了一些额外的处理</p>
<ul>
<li>如果对一个事件添加超过 10 个侦听器，将会得到一条警告。可以调用 <code>emmiter.setMaxListeners(0)</code>去除限制</li>
<li>EventEmmiter 对象对 error 事件进行了特殊对待。如果运行期间的错误触发了 error 事件，EventEmitter 会检查是否由对 error 事件添加过侦听器。如果有，则将错误交给该侦听器处理，否则作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出</li>
</ul>
<p>通过继承 events 模块可实现事件机制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Stream, events.EventEmitter);</span><br></pre></td></tr></table></figure>
<h4 id="多异步之间的协作方案">多异步之间的协作方案</h4><p>由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间相互没有任何交集，因此需要借助一个第三方函数和第三方变量来处理异步写作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>, results = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        results[key] = value;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count === times) &#123;</span><br><span class="line">            callback(results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.Emitter();</span><br><span class="line"><span class="keyword">var</span> done = after(times, render);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'done'</span>, done);</span><br><span class="line"></span><br><span class="line">fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    emitter.emit(<span class="string">'done'</span>, <span class="string">'template'</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    emitter.emit(<span class="string">'done'</span>, <span class="string">'data'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span>(<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">    emitter.emit(<span class="string">'done'</span>, <span class="string">'resources'</span>, resources);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 EventProxy 解决异步协作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> EventProxy();</span><br><span class="line">proxy.all(<span class="string">'template'</span>, <span class="string">'data'</span>, <span class="string">'resources'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">template, data, resources</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">'template'</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">'data'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span>(<span class="params">resources</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">'resources'</span>, resources)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise_/_Deferred_模式">Promise / Deferred 模式</h3><h4 id="Promise/A">Promise/A</h4><p>Promise/A 对单个异步操作的抽象定义如下</p>
<ul>
<li>Promise 只会出于三种状态中的一种：未完成态、完成态或失败态</li>
<li>Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆转。完成态和失败态不能相互转化</li>
<li>Promise 的状态一旦转化，将不能被改变</li>
</ul>
<p>Promise/A 提议在 API 的定义中，一个 Promise 对象只要具备 then() 方法即可，有如下要求</p>
<ul>
<li>接受完成态、错误态的回调函数。在操作完成或者出现错误时，将会调用对应方法</li>
<li>可选地支持 progress 事件回调作为第三个方法</li>
<li>then() 方法只接受 function dioxide。其余对象将被忽略</li>
<li>then() 方法继续放回 Promise 对象，以实现链式调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(fulfilledHandler, errorHandler, progressHandler)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">util.inherits(<span class="built_in">Promise</span>, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">fulfilledHandler, errorHandler, progressHandler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.once(<span class="string">'success'</span>, fulfilledHandler);</span><br><span class="line">    <span class="keyword">this</span>.once(<span class="string">'error'</span>, errorHandler);</span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'progress'</span>, progressHandler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>then() 方法将回调函数存放起来。为了完成整个流程，还需要执行这些回调函数的地方，实现这些功能的对象称为 Deferred，即延迟对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'unfulfilled'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'success'</span>, obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'failed'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'error'</span>, err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.progress = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'progress'</span>, data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>封装业务代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promisify = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">    </span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        result += chunk;</span><br><span class="line">        deferred.progress(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferred.resolve(result);</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        deferred.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型响应对象的调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promisify(res).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Error</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// progress</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'BODY: '</span> + chunk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>与事件发布/订阅模式相比，Promise/Deferred 模式的 API 接口和抽象模型都十分简洁。它将业务中不可变的部分封装在了 Deferred 中，将可变的部分交给了 Promise。对于不同场景需要封装对应的 Deferred 部分</p>
<p>多异步协作可通过哨兵变量和 result 数组实现</p>
<h4 id="流程控制库">流程控制库</h4><ul>
<li><p>尾触发与 Next<br>需要手工调用才能持续执行后续调用的方法属于尾触发，常见的关键词是 next。目前应用最多的 diff 是 Connect 的中间件，在处理网络请求时，可以像面向切面编程一样进行过滤，验证，日志等功能，而不与具体业务逻辑产生关联，以致产生耦合</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(connect.staticCache());</span><br><span class="line">app.use(connect.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(connect.query());</span><br><span class="line">app.use(connect.bodyParse());</span><br><span class="line">app.listen(<span class="number">3001</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>async</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// result =&gt; [file1.txt, file2.txt]s</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Step</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串行依次执行</span></span><br><span class="line">Step(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readFile1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readFile2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(content);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>wind</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Wind = <span class="built_in">require</span>(<span class="string">'wind'</span>);</span><br><span class="line"><span class="keyword">var</span> Task = Wind.Async.Task;</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">file, encoding</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.create(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        fs.readFile(file, encoding, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.err) &#123;</span><br><span class="line">                t.complete(<span class="string">'failure'</span>, err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.complete(<span class="string">'success'</span>, file)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> series = <span class="built_in">eval</span>(Wind.compile(<span class="string">'async'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> file1 = $<span class="keyword">await</span>(readFileAsync(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(file1);</span><br><span class="line">    <span class="keyword">var</span> file2 = $<span class="keyword">await</span>(readFileAsync(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(file2);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> file1 = $<span class="keyword">await</span>(readFileAsync(<span class="string">'file3.txt'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="异步并发控制">异步并发控制</h4><ul>
<li><p>bagpipe 的解决方案</p>
<ul>
<li>通过一个队列来控制并发量</li>
<li>如果当前活跃的异步调用量小于限量值，从队列中取出执行</li>
<li>如果活跃调用达到限量值，调用暂时存放在队列中</li>
<li><p>每个异步调用结束时，从队列中取出新的异步调用执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Bagpipe = <span class="built_in">require</span>(<span class="string">'bagpipe'</span>);</span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">    bagpipe.push(<span class="keyword">async</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 异步回调执行</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">bagpipe.on(<span class="string">'full'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'full queue: '</span> + length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>async</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallelLimit([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> q = <span class="keyword">async</span>.queue(<span class="function"><span class="keyword">function</span>(<span class="params">file, callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(file, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line">q.drain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// done</span></span><br><span class="line">&#125;;</span><br><span class="line">fs.readdirSync(<span class="string">'.'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    q.push(file, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="内存控制">内存控制</h2><h3 id="V8的垃圾回收机制与内存限制">V8的垃圾回收机制与内存限制</h3><p>在 V8 中，所有的 Javascript 对象都是用过堆来进行分配的。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制。V8 限制堆的大小，原因在于垃圾回收中会引起 Javascript 线程暂停执行，而糟糕情况下造成的时间花销将影响应用性能和响应能力</p>
<p>V8 中，将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或者常驻内存的对象</p>
<p>分代的基础上，新生代中的对象主要通过 Scavenge 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用了 Cheney 算法。简单表述，在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间中进行复制，属于典型的牺牲空间换取时间的算法</p>
<p>在一定条件下，需将存活周期长的对象移动到老生代中，也就是完成对象晋升。判断条件为对象是否经历过 Scavenge 回收和 To 空间的内存占用比超过限制</p>
<p>老生代空间中得对象接受新的回收算法处理，主要采用 Mark-Sweep 和 Mark-Compact 相结合的方式。Mark-Sweep 是标记清楚的意思，分为标记和清理清除两个阶段；Mark-Compact 解决 Mark-Sweep 的内存碎片问题，将存活的对象往一端移动，完成后直接清理掉边界外的内存</p>
<p>为了避免出现 Javascript 应用逻辑与垃圾回收期看到不一致的情况，垃圾回收的3种基本算法都需将应用逻辑暂停下来，待执行完垃圾回收之后在回复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。全堆垃圾回收的标记、清理、整理等动作造成的停顿比较可怕，因此采用增量标记（incremental marking），垃圾回收与应用逻辑交替执行直到标记阶段完成</p>
<h3 id="高效使用内存">高效使用内存</h3><h4 id="作用域">作用域</h4><p>在 Javascript 中能形成作用域的有函数调用、with 和全局作用域。作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁</p>
<p>如果变量是全局变量（不通过 var 声明或定义在 global 上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过 delete 操作来删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系，在接下来的老生代内存清除和整理的过程中，会被回收释放</p>
<h4 id="闭包">闭包</h4><p>实现外部作用域访问内部作用域中的变量的方法叫做闭包。一旦有变量引用内部作用域的变量，原始的作用域不会得到释放</p>
<h3 id="内存指标">内存指标</h3><h4 id="查看进程的内存占用">查看进程的内存占用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.memoryUsage()</span><br><span class="line"><span class="comment">// =&gt; &#123;rss: 13852672, heapTotal: 6131200, heapUsed: 2757120&#125;</span></span><br></pre></td></tr></table></figure>
<p>rss 是 resident set size 的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区（swap）或者文件系统（filesystem）中</p>
<p>除了 rss 外，heapTotal 和 heapUsed 对应的是 V8 的堆内存信息，heapTotal 是堆中总共申请的内存量，heapUsed 表示目前堆中使用中的内存量。三个值的单位都是字节</p>
<h4 id="查看系统内存占用">查看系统内存占用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">os.totalmem()</span><br><span class="line"><span class="comment">// =&gt; 8589934592</span></span><br><span class="line">os.freemem()</span><br><span class="line"><span class="comment">// =&gt; 1025601536</span></span><br></pre></td></tr></table></figure>
<h4 id="堆外内存">堆外内存</h4><p>process.memoryUsage() 的结果可知，堆中的内存用量总是小于进程的常驻内存用量，意味着 Node 中的内存使用并非都是通过 V8 进行分配的，我们将那些不是通过 V8 分配的内存称为堆外内存</p>
<p>Buffer 对象不同于其他对象，它不经过 V8 的内存分配机制，所以不会有堆内存的大小限制</p>
<h4 id="小结-1">小结</h4><p>Node 的内存构成主要是通过 V8 进行分配的部分和 Node 自行分配的部分，受 V8 的垃圾回收限制的主要是 V8 的堆内存</p>
<h3 id="内存泄露">内存泄露</h3><p>实质是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。可能的原因有：缓存、队列消费不及时、作用域未释放</p>
<h4 id="缓存限制机制">缓存限制机制</h4><p>由于模块的缓存机制，模块都是常驻老生代的。在设计模块时，要十分小心内存泄露的出现，避免调用导出方法时不停增加内存的占用。当不可避免时可添加相关接口供使用者释放内存</p>
<h4 id="缓存的解法方案">缓存的解法方案</h4><p>大量使用缓存的一个解决方法是使用进程外的缓存，进程自身不储存状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能，在 Node 中可解决以下问题</p>
<ul>
<li>将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更加高效</li>
<li>进程之间可以共享缓存</li>
</ul>
<h4 id="关注队列状态">关注队列状态</h4><p>队列在消费者-生产者模式中经常充当中间产物，当消费速度低于生成速度，将会形成堆积，出现内存泄露。表面的解决方案是换用消费速度更高的技术；深度的解决方案是监控队列的长度，一旦堆积，应通过监控系统产生报警通知相关人员，或者为任意异步调用添加超时机制</p>
<h3 id="内存泄露排查">内存泄露排查</h3><p>定位 Node 应用的内存泄露的常用工具如下：</p>
<ul>
<li>v8-profiler</li>
<li>node-heapdump</li>
<li>dtrace</li>
<li>node-memwatch</li>
</ul>
<h2 id="理解_Buffer">理解 Buffer</h2><h3 id="Buffer_结构">Buffer 结构</h3><h4 id="模块结构">模块结构</h4><p>Buffer 是一个典型的 Javascript 与 C++ 结合的模块，它将性能相关部分用 C++ 实现，将非性能相关的部分用 Javascript 实现</p>
<h4 id="Buffer_对象">Buffer 对象</h4><p>Buffer 对象类似数组，它的元素为16进制的两位数，即0到255的数值。其中中文字符在 UTF-8 编码下占用3个元素，字母和半角标点符号占用一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'深入浅出node.js'</span>;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(str, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"><span class="comment">// =&gt; &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span></span><br></pre></td></tr></table></figure>
<p>给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于256，就逐次减256。如果是小数，舍弃小数部分，只保留整数部分</p>
<h4 id="Buffer_内存分配">Buffer 内存分配</h4><p>Node 使用 slab 分配机制使用申请来的内存。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和事后分配，使得 Javscript 到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的 Buffer 而言，则直接使用 C++ 层面提供的内存，而无需细腻的分配操作</p>
<h3 id="Buffer_的转换">Buffer 的转换</h3><p>Buffer 对象与字符串之间相互转换，目前支持的字符串编码类型如下：</p>
<ul>
<li>ASCII</li>
<li>UTF-8</li>
<li>UTF-16LE/UCS-2</li>
<li>Base64</li>
<li>Binary</li>
<li>Hex</li>
</ul>
<h4 id="字符串转_Buffer">字符串转 Buffer</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</span><br><span class="line">buf.write(string, [offset], [length], [encoding]);</span><br></pre></td></tr></table></figure>
<p>通过构造函数转换的 Buffer 对象，存储的只能是一种编码类型，encoding 参数不传递时，默认按 UTF-8 编码进行转码和存储。调用 write() 方法可以在一个 Buffer 对象中存储不同编码类型的字符串编码的至，但需要小心每种编码所用的字节长度不同，将 Buffer 对象反转成字符串时需谨慎处理</p>
<h4 id="Buffer_转字符串">Buffer 转字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end]);</span><br></pre></td></tr></table></figure>
<h4 id="buffer_不支持的编码类型">buffer 不支持的编码类型</h4><p>Buffer 对象提供 isEncoding() 函数判断编码是否支持转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Buffer.isEncoding(encoding);</span><br></pre></td></tr></table></figure>
<p>可借助 iconv-lite 或 iconv 支持更多编码类型。前者采用纯 Javascript 实现，更轻量，无需编译和处理环境依赖直接使用；后者通过 C++ 调用 libiconv 库实现。性能方面由于转码都是耗用 CPU，在 V8 下少了 C++ 到 Javascript 层次的转换，纯 Javascript 的性能比 C++ 实现更好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = iconv.decode(buf, <span class="string">'win1251'</span>);</span><br><span class="line"><span class="keyword">var</span> buf = iconv.encode(str, <span class="string">'win1251'</span>);</span><br></pre></td></tr></table></figure>
<p>iconv-lite 和 iconv 对无法转换的内容进行降级处理时的方案不同</p>
<h3 id="Buffer_的拼接">Buffer 的拼接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'rs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data 事件中获取的 chunk 对象即是 Buffer 对象。因此，拼接 data 的过程中，相当于隐藏调用了<code>chunk.toString()</code>（默认以UTF-8编码）。如果存在宽字节编码，则可能出现乱码</p>
<p>可以通过为可读流设置编码，使 data 事件中传递的不再是一个 Buffer 对象，而是编码后的字符串.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line">fs.setEncoding(<span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure>
<p>事实上，调用 setEncoding() 时，可读流对象在内部设置了一个 decoder 对象。每次都通过该 decoder 对象进行 Buffer 到字符串的解码，然后传递给调用者。decoder 对象来自于 string_decoder 模块 StringDecoder 的实例对象，能根据编码类型处理可读流的字节长度问题。但它目前只能处理 UTF-8、 Base64 和 UCS-2/UTF-16LE 这三种编码</p>
<p>可通过 iconv-lite 一类的模块，将可读流获取的 Buffer 对象拼接后做转换，解决转码问题</p>
<h3 id="Buffer_与性能">Buffer 与性能</h3><p>字符串一旦在网络中传输，都需要转换为 Buffer，以进行二进制数据传输。通过预先转换静态内容为 Buffer 对象，可以有效地减少 CPU 的重复使用，节省服务器资源</p>
<p>Buffer 的使用除了与字符串的转换有性能耗损外，在文件读取时，还有一个 highWaterMark 设置对性能的影响至关重要。highWaterMark 限制每次读取的长度，对 Buffer 内存的分配和使用有一定影响，设置过小可能导致系统调用次数过多。</p>
<p>文件流读取基于 Buffer 分配，Buffer 则基于 SlowBuffer 分配</p>
<h2 id="网络编程">网络编程</h2><p>Node 提供了 net、 dgram、 http、 https 这4个模块，分别用于处理 TCP、 UDP、 HTTP、 HTTPS</p>
<h3 id="构建_TCP_服务">构建 TCP 服务</h3><p>TCP 全名为传输控制协议，在 OSI 模型（由七层组成，分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于 TCP 构建，典型的是 HTTP、 SMTP、 IMAP 等协议</p>
<p>TCP 是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端和客户端则通过套接字实现两者之间连接的操作</p>
<h4 id="服务器事件">服务器事件</h4><ul>
<li><p>listening：在调用 server.listen() 绑定端口或者 Domain Socket 后触发，简洁写法为</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.listen(port, listeneringListener)</span><br></pre></td></tr></table></figure>
</li>
<li><p>connection：每个客户端套接字连接到服务器端时触发，简介写法为通过 net.createServer()，最后一个参数传递</p>
</li>
<li>close：当服务器关闭时触发，在调用 server.close() 后，服务器将停止接受新的套接字连接，但保存当前存在的连接，等待所有连接都断开后，会触发该事件</li>
<li>error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常。如果不侦听 error 事件，服务器将会抛出异常</li>
</ul>
<h4 id="连接事件">连接事件</h4><p>服务器可以通过与多个客户端保持连接，对于每个连接而言是典型的可写可读 Stream 对象。Stream 可用户与服务器和客户端之间的通信，它具有如下自定义事件</p>
<ul>
<li>data：当一段调用 write() 发送数据时，另一端会触发 data 事件</li>
<li>end：当连接中的任意一端发送了 FIN 数据时，触发该事件</li>
<li>connect：用于客户端，当套接字与服务器端连接成功时被触发</li>
<li>drain：当任意一端调用 write() 发送数据时，当前这端会触发该事件</li>
<li>error：异常发生时候触发</li>
<li>close：当套接字完全关闭时触发</li>
<li>timeout：当一定时间后连接不再活跃时触发，通知用户当前该连接已经被闲置</li>
</ul>
<p>TCP 针对网络中的小数据包有一定的优化策略：Nagle 算法。要求缓冲区的文件达到一定数量或者一定时间后才将其发出，所以数据包会被 Nagle 算法合并，以此优化网络，但数据可能被延迟发送。Node 中 TCP 默认使用 Nagle 算法，可以使用<code>socket.setNoDelay(true)</code>取消。尽管如此，并不意味着每次 write() 都会触发一次 data 事件，另一端可能将会接收到多个小数据包合并，然后只触发一次 data 事件</p>
<h3 id="构建_UDP_服务">构建 UDP 服务</h3><p>UDP 又称用户数据包协议，与 TCP 一样属于网络传输层。与 TCP 最大不同是 UDP 不是面向连接的。TCP 中连接一旦建立，所有的会话都会基于连接完成，客户端如果要与另一个 TCP 服务通信，需要另外创建一个套接字来完成连接。但在 UDP 中，一个套接字可以与多个 UDP 服务通信，它提供面向事务的简单不可靠信息传输服务，在网络差的情况下丢包严重，但由于它无需连接，资源消耗低，处理快速且灵活，所以常用于偶尔丢包也不会产生重大影响的场景，如音频、视频等。DNS 服务是基于 UDP 实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">var</span> server = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg, rinfo</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server got: '</span> + msg + <span class="string">'from '</span> + rinfo.address);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> address = server.address();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server listening '</span> + address.address);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 该套接字将接受所有网卡上41234端口上的消息</span></span><br><span class="line"><span class="comment">// 绑定完成后将触发 listening 事件</span></span><br><span class="line">server.bind(<span class="number">41234</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> Buffer(<span class="string">'msg from client'</span>);</span><br><span class="line"><span class="keyword">var</span> client = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line">client.send(message, <span class="number">0</span>, message.length, <span class="number">41234</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>) </span>&#123;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="UDP_套接字事件">UDP 套接字事件</h4><p>UDP 套接字只是一个 EventEmitter 的实例，而非 Stream 的实例</p>
<ul>
<li>message：当 UDP 套接字侦听网卡端口后，接受到消息时触发该事件，触发携带的数据为消息 Buffer 对象和一个远程地址信息</li>
<li>listening：当 UDP 套接字开始侦听时触发事件</li>
<li>close：调用 close() 方法时触发该事件，并不再触发 message 事件</li>
<li>error：当异常发生时触发该事件，如果不侦听，异常将直接抛出</li>
</ul>
<h3 id="构建_HTTP_服务">构建 HTTP 服务</h3><p>TCP 和 UDP 都属于网络传输层协议，如果要构造高效的网络应用，应该从传输层进行着手。HTTP 构建与 TCP 之上</p>
<h4 id="HTTP_报文">HTTP 报文</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -v http://baidu.com</span><br><span class="line">* Rebuilt URL to: http://baidu.com/</span><br><span class="line">*   Trying <span class="number">180.149</span>.<span class="number">132.47</span>...</span><br><span class="line">* Connected to baidu.com (<span class="number">180.149</span>.<span class="number">132.47</span>) port <span class="number">80</span> (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.43</span>.<span class="number">0</span></span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">&lt; Date: Sat, <span class="number">22</span> Aug <span class="number">2015</span> <span class="number">14</span>:<span class="number">07</span>:<span class="number">42</span> GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Cache-Control: max-age=<span class="number">86400</span></span><br><span class="line">&lt; Expires: Sun, <span class="number">23</span> Aug <span class="number">2015</span> <span class="number">14</span>:<span class="number">07</span>:<span class="number">42</span> GMT</span><br><span class="line">&lt; Last-Modified: Tue, <span class="number">12</span> Jan <span class="number">2010</span> <span class="number">13</span>:<span class="number">48</span>:<span class="number">00</span> GMT</span><br><span class="line">&lt; ETag: <span class="string">"51-4b4c7d90"</span></span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: <span class="number">81</span></span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection <span class="comment">#0 to host baidu.com left intact</span></span><br></pre></td></tr></table></figure>
<p>第一部分是 TCP 的3次握手的过程；第二部分是完成握手之后，客户端向服务器端发送请求报文；第三部分是服务器端完成处理后，向客户端发送响应内容，包括响应头和响应体；最后是结束会话的信息</p>
<p>HTTP 是基于请求响应式的，虽然基于 TCP 会话，但本身却并无会话的特点</p>
<h4 id="http_模块">http 模块</h4><p>HTTP 服务与 TCP 服务模型由区别的地方在于，在开启 keepalive 后，一个 TCP 服务可以用于多次请求和响应。TCP 服务以 connection 为单位进行服务，HTTP 服务以 request 为单位进行服务。http 模块即是将 connection 到 request 的过程进行了封装</p>
<p>除此之外，http 模块将连接所用套接字的读写抽象为 ServerRequest 和 ServerResponse 对象，分别对应请求和响应操作</p>
<h4 id="HTTP_请求">HTTP 请求</h4><p>对于 TCP 连接的读操作，http 模块将其封装为 ServerRequest 对象。报文头被解析防止在 req.headers 属性上，报文体部分则抽象为一个只读流对象</p>
<h4 id="HTTP_响应">HTTP 响应</h4><p>封装了对底层连接的写操作，可以将其看做一个可写的流对象。报文头信息通过<code>setHeader()</code>和<code>writeHead()</code>写入，报文体通过调用<code>res.write()</code>和<code>res.end()</code>方法实现。无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用<code>res.end()</code>结束请求，否则客户端将会一直处于等待状态。也可以通过延迟 res.end() 的方法实现客户端与服务器端的长连接，但结束时务必关闭连接</p>
<h4 id="HTTP_服务的事件">HTTP 服务的事件</h4><ul>
<li>connection 事件：在开始 HTTP 请求和响应之前，客户端与服务器端需要建立底层的 TCP 连接，这个连接可能因为开启了 keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次 connection 事件</li>
<li>request 事件：建立 TCP 连接后，http 模块底层将在数据流中抽象出 HTTP 请求和 HTTP 响应，当请求数据发送到服务器端，在解析出 HTTP 请求头后，将会触发该事件；在 res.end() 之后，TCP 连接可能将用于下一次响应请求</li>
<li>close 事件：与 TCP 服务器的行为一致，调用 server.close() 方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给 server.close() 传递一个回调函数来快速注册该事件</li>
<li>checkContinue 事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带<code>Except: 100-continue</code>的请求到服务器，服务器触发该事件；如果没有为服务器监听该事件，服务器将会自动响应客户端<code>100 Continue</code>的状态码，表示接受数据上传；否则响应<code>400 Bad Request</code>拒绝客户端发送数据。需要注意的是，该事件不会触发 request 事件，两个事件互斥。当客户端收到<code>100 Continue</code>后重新发起请求时，才会触发 request 事件</li>
</ul>
<h4 id="HTTP_客户端">HTTP 客户端</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    hostname: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="string">'1334'</span>,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    method: <span class="string">'GET'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// res.statusCode;</span></span><br><span class="line">    <span class="comment">// res.headers;</span></span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>options 参数决定了 HTTP 请求头的内容</p>
<ul>
<li>host：服务器的域名或 IP 地址，默认为 localhost</li>
<li>hostname：服务器名称</li>
<li>port：服务器端口，默认为 80</li>
<li>localAddress：建立网络连接的本地网卡</li>
<li>socketPath：Domain 套接字路径</li>
<li>method：HTTP 请求方法，默认为 GET</li>
<li>path：请求路径，默认为 /</li>
<li>headers：请求头对象</li>
<li>auth：Basic 认证，这个值将被计算成请求头中的 Authorization 部分</li>
</ul>
<h4 id="HTTP_代理">HTTP 代理</h4><p>http 提供的 CLientRequest 对象也是基于 TCP 层实现，在 keepalive 的情况下，一个底层会话连接可以多次用于请求。为了重用 TCP 链接，http 模块包含一个默认的客户端代理对象 http.globalAgent。它对每个服务器端（host+port）创建的连接进行了管理，默认情况下，通过 ClientRequest 对象对同一个服务器发情的 HTTP 请求最多可以创建五个连接。它实质上是一个连接池</p>
<p>服务器通过 ClientRequest 调用网络中其它 HTTP 服务，需要关注代理对象对网络请求的限制。可通过 options 中的 agent 选项配置。默认情况下采用全局代理对象，默认连接数限制为5</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> agent = <span class="keyword">new</span> http.Agent(&#123;</span><br><span class="line">    <span class="comment">// 设置为 false 则脱离连接池管理，请求不受并发限制</span></span><br><span class="line">    maxSockets: <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    hostname: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="string">'1334'</span>,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    method: <span class="string">'GET'</span>,</span><br><span class="line">    agent: agent</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="HTTP_客户端事件">HTTP 客户端事件</h4><ul>
<li>response：与服务器端的 request 事件对应的客户端在请求发出后得到服务器端响应时触发</li>
<li>socket：当底层连接池中建立的连接分配给当前请求对象时触发</li>
<li>connect：当客户端向服务器端发情 CONNECT 请求时，如果服务器端响应 200 状态吗，客户端将会触发事件</li>
<li>upgrade：客户端向服务器端发送 Upgrade 请求时，如果服务器端响应了 101 Switching Protocols 状态，客户端将会触发该事件</li>
<li>continue：客户端向服务器端发起 Expect: 100-continue 头信息，以试图发送较大数据量，如果服务器端响应 100 Continue 状态，客户端触发该事件</li>
</ul>
<h3 id="构建_WebSocket_服务">构建 WebSocket 服务</h3><p>WebSocket 协议主要分为握手和数据传输两部分。相比 HTTP，WebSocket 更接近于传输层协议，它并没有在 HTTP 的基础上模拟服务器端的推送，而是在 TCP 上定义独立的协议。但 WebSocket 的握手部分是由 HTTP 完成的</p>
<h4 id="WebSocket_握手">WebSocket 握手</h4><p>客户端请求报文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Set-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ</span><br><span class="line">Set-WebSocket-Protocol: chat, superchat</span><br><span class="line">Set-WebSocket-Version: <span class="number">13</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Upgrade, Connect：表示请求服务器端升级协议为 WebSocket</li>
<li>Set-WebSocket-Key：随机生成的 Base64 编码的字符串，用于安全校验</li>
<li>Set-WebSocket-Protocol：指定子协议</li>
<li>Set-WebSocket-Version：指定版本号</li>
</ul>
<p>服务器端响应报文</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo</span><br><span class="line">sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<h4 id="WebSocket_数据传输">WebSocket 数据传输</h4><p>在握手顺利完成后，当前连接将不再进行 HTTP 的交互，而是开始 WebSocket 的数据帧协议，实现客户端与服务器端的数据交换</p>
<p>WebSocket 数据帧的定义，每八位为一列，也即1个字节</p>
<p><img src="/images/168-7-7.png" alt="WebSocket 数据帧"></p>
<ul>
<li>fin：如果这个数据帧是最后一帧，这个 fin 位为1，其余情况为0.当一个数据没有被分为多帧时，它既是第一帧也是最后一帧</li>
<li>rsv1、 rsv2、 rsv3：各为1位长，3个标识用于扩展，当已协商的扩展时，这些值可能为1，其余情况为0</li>
<li>opcode：长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。0表示附加数据帧，1表示文本数据帧，2表示二进制数据帧，8表示发送一个连接关闭的数据帧，9表示 ping 数据帧，10表示 pong 数据帧，其余值暂时没有定义。ping 和 pong 用于心跳检测</li>
<li>masked：表示是否进行掩码处理，长度为1.客户端发送给服务器端时为1，服务器端发送给客户端为0</li>
<li>payload length：一个7、 7+16 或 7+64 位长的数据位，标识数据的长度。如果值在 0~125 间，那么该值就是数据的真实长度；如果值是126，则后面16位的值是数据的真实长度；如果值是127，那么后面64位的值是数据的真实长度</li>
<li>masking key：当 masked 为1时存在，是一个32位长的数据位，用于解密数据</li>
<li>payload data：模板数据，位数为8的倍数</li>
</ul>
<h3 id="网络服务与安全">网络服务与安全</h3><p>Node 在网络安全上提供了 crypto、 tls、 https 三个模块</p>
<h4 id="TLS/SSL">TLS/SSL</h4><p>TLS/SSL 是一个公钥/密钥的结构，它是一个非对称的结构。公钥和密钥配对的，在建立安全传输前，客户端和服务器之间需要互换密钥。客户端发送服务器数据时要通过服务器端的公钥加密，服务器端发送数据时要通过客户端的公钥加密</p>
<p>为了解决中间人攻击问题，引入了数字证书进行认证，即 CA（Certificate Authority 数字证书认证中心）。CA 的作用是为站点颁发证书，且这个证书具有 CA 通过自己的公钥和密钥实现的签名</p>
<p>TLS 服务与普通的 TCP 服务仅仅只在证书的配置上有差别，其余部分基本相同</p>
<h4 id="HTTPS">HTTPS</h4><p>HTTPS 服务就是工作在 TLS/SSL 上的 HTTP。同样比 HTTP 服务多了证书的配置，其余部分基本相同</p>
<h2 id="构建_Web_应用">构建 Web 应用</h2><h4 id="请求方法">请求方法</h4><p>在 RESTful 类 Web 服务中请求方法十分重要，因为它决定资源的操作行为。PUT 表示新建一个资源，POST 表示更新一个资源，GET 表示查看一个资源，DELETE 表示删除一个资源</p>
<h4 id="路径解析">路径解析</h4><p>常见的根据路径进行业务处理的应用是静态文件服务器，它会根据路径去查找磁盘中的文件，然后响应给客户端；另一种常见的分发场景是根据路径来选择控制器，它预设路径为控制器和行为的组合，无需额外配置路由信息</p>
<h4 id="查询字符串">查询字符串</h4><p>Node 提供 url 和 querystring 两个模块处理 url 及 url 的查询串。通常情况下，不需要直接处理querystring，因为url模块的支持</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> query = url.parse(req.url, <span class="literal">true</span>).query;</span><br><span class="line"><span class="comment">// =&gt; &#123;foo: 'bar', baz: 'val'&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果查询字符串中的键出现多次，那么它的值会是一个数组</p>
<h4 id="Cookie">Cookie</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Set-Cookie: name=value; Path=/; Expire=Sun, <span class="number">21</span>-Apr-<span class="number">21</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">11</span> GMT; Domain=.domain.com</span><br></pre></td></tr></table></figure>
<ul>
<li>path：表示这个 Cookie 影响到的路径，当前访问路径不满足该匹配时，浏览器不发送这个 Cookie</li>
<li>Expires 和 Max-Age 用来告知浏览器这个 Cookie 何时过期，如果不设置该选项，关闭浏览器将丢失 Cookie，否者浏览器会将 Cookie 内容写入磁盘保存，下次打开浏览器依然有效。Expires 的值是一个 UTC 格式的时间字符串，告知浏览器 Cookie 几时过期，Max-Age 告知 Cookie 多久之后过期</li>
<li>HttpOnly 告知浏览器不允许通过脚本 document.cookie 去改变 Cookie 值</li>
<li>Secure 为 true 时在 HTTP 中无效，在 HTTPS 中表示创建的 Cookie 只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证</li>
</ul>
<h5 id="Cookie_的性能影响">Cookie 的性能影响</h5><p>Cookie 设置过多将导致报头较大，且大多数 Cookie 不是必须的</p>
<ul>
<li><p>减小 Cookie 大小<br>  如果在域名的根节点设置 Cookie，几乎所有的子路径的请求都会带上这些 Cookie。而静态文件的业务定位几乎不关心状态，Cookie 是多余的</p>
</li>
<li><p>为静态组件使用不同的域名<br>  为不需要 Cookie 的组件更换域名可以实现减少无效的 Cookie 的传输。换用域名同时可以突破浏览器下载线程数量的限制。但是换用域名会存在 DNS 查询的耗时问题</p>
</li>
<li><p>减少 DNS 查询<br>  限制通过多个域名加载资源。当今浏览器会进行 DNS 缓存，削弱了这个副作用的影响</p>
</li>
</ul>
<h4 id="Session">Session</h4><h5 id="通过_Session_实现状态记录的几种方法">通过 Session 实现状态记录的几种方法</h5><ul>
<li><p>基于 Cookie 实现用户和数据的映射<br>  Session 的数据只保留在服务器，并约定一个键值作为 Session 的口令保存在 Cookie。每次请求到来时，检查 Cookie 中的口令和服务器端的数据，如果过期，则重新生成</p>
</li>
<li><p>通过查询字符串实现浏览器端和服务器端数据的对应<br>  原理是检查请求的查询字符串，如果没有该值，则生成新的带值得字符串，做 302 跳转</p>
</li>
<li><p>通过 HTTP 请求头的 ETag 实现数据映射</p>
</li>
</ul>
<h5 id="Session_与内存">Session 与内存</h5><p>一方面，Node 存在内存限制，将 Session 的数据存放在内存中在用户增多的情况下存在隐患，将引起垃圾回收的频繁扫描，引起性能问题；另一方面，如果利用多核 CPU 启动多个进程，则用户请求的连接可能随意分配到各个进程中，Node 的进程间无法共享内存，则用户的 Session 可能引起错乱</p>
<p>针对上述问题，常用的方法是 Session 集中化，将原本可能分散在多个内存中的数据，统一转移到集中的数据存储中，常用的工具有 Redi Memcached 等</p>
<h5 id="Session_与安全">Session 与安全</h5><p>由于口令存放在客户端，则可能被伪造并窃取服务器端的数据。可以将口令通过私钥加密进行签名，使得伪造的成本较高</p>
<h4 id="缓存">缓存</h4><p>YSlow 提到的关于缓存的规则</p>
<ul>
<li>添加 Expires 或 Cache-Control 到报文头中</li>
<li>配置 ETags</li>
<li>让 Ajax 可缓存</li>
</ul>
<table>
<thead>
<tr>
<th>报文头</th>
<th>值/示例</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Expires</td>
<td>UTC 字符串</td>
<td>响应</td>
<td>告诉浏览器在过期时间前可以使用副本</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>no-chche</td>
<td>响应</td>
<td>告诉浏览器忽略资源的缓存副本，强制每次请求直接发送给服务器</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>no-store</td>
<td>响应</td>
<td>强制缓存在任何情况下不要保留副本</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>max-age=[秒]</td>
<td>响应</td>
<td>执行缓存副本的有效时长，从请求时间开始到过期时间之间的秒数</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>public</td>
<td>响应</td>
<td>任何途径的缓存者（本地缓存，代理服务器）可以无条件缓存该资源</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>private</td>
<td>响应</td>
<td>只针对单个用户或实体（不同用户，窗口）缓存资源</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>UTC 字符串</td>
<td>响应</td>
<td>告诉浏览器当前资源最后修改时间</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>UTC 字符串</td>
<td>请求</td>
<td>如果浏览器第一次请求时响应中 Last-Modified 非空，第二次请求会把该项的值发送给服务器</td>
</tr>
<tr>
<td>ETags</td>
<td>标识符</td>
<td>响应</td>
<td>告知浏览器当前资源在服务器的唯一标识符（生成规则由服务器决定）</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>标识符</td>
<td>请求</td>
<td>果浏览器第一次请求时响应中 ETags 非空，第二次请求会把该项的值发送给服务器</td>
</tr>
</tbody>
</table>
<p>有如下两种更新机制：</p>
<ul>
<li>每次发布，路径中跟随 Web 应用的版本号，如：<a href="http://url.com/?v20120917" target="_blank" rel="external">http://url.com/?v20120917</a></li>
<li>每次发布时，路径中跟随该文件内容的 hash 值，如：<a href="http://url.com/?hash=abcdxxx" target="_blank" rel="external">http://url.com/?hash=abcdxxx</a></li>
</ul>
<h4 id="Basic_认证">Basic 认证</h4><p>Basic 认证中，它会将用户和密码部分组合，然后进行 Base64 编码。响应头中的 WWW-Authenticate 字段告知浏览器采用怎样的认证和加密方式。当认证通过，服务器端响应200状态码之后，浏览器会保存用户和密码口令，在后续的请求中都携带上 Authorization 信息</p>
<h3 id="数据上传">数据上传</h3><h4 id="表单数据">表单数据</h4><p>默认的表单提交，请求头中的 Content-Type 字段值是 application/x-www-form-urlencoded 。由于它的报文体内容与查询字符串相同，因此可以使用 querystring 解析</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.headers[<span class="string">'content-type'</span>] === <span class="string">'application/x-www-form-urlencoded'</span>) &#123;</span><br><span class="line">        req.body = querystring.parse(req.rawBody);</span><br><span class="line">    &#125;;</span><br><span class="line">    todo(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JSON_文件">JSON 文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mime(req) === <span class="string">'application/json'</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            req.body = <span class="built_in">JSON</span>.parse(req.rawBody);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            res.writeHead(<span class="number">400</span>);</span><br><span class="line">            res.end(<span class="string">'Invalid JSON'</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    todo(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="XML_文件">XML 文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xml2js = reuqire(<span class="string">'xml2js'</span>);</span><br><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mime(req) === <span class="string">'application/xml'</span>) &#123;</span><br><span class="line">        xml2js.parseString(req.rawBody, <span class="function"><span class="keyword">function</span>(<span class="params">err, xml</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                res.writeHead(<span class="number">400</span>);</span><br><span class="line">                res.end(<span class="string">'Invalid xml'</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            req.body = xml;</span><br><span class="line">            tody(req, res);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    todo(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="附件上传">附件上传</h4><p>指定表单属性 enctype 为 multipart/form-data，则其报文头如下</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: <span class="string">multipart/form-data; boundary=AaBo3x</span></span><br><span class="line"><span class="attribute">Content-Length</span>: <span class="string">18231</span></span><br></pre></td></tr></table></figure>
<p>代表本次提交的内容是由多部分构成的，其中 boundary=AaBo3x 指定每部分内容的分界符，AaBo3x 是随机生成的字符串，报文体的内容将通过在它前面添加<code>--</code>分隔，报文结束时在它前后都加上<code>--</code>表示结束。Content-Length 表示报文长度，太长则在 keep-alive 的情况下浏览器保持等待请求，太短则报文被截断</p>
<p>可通过 formidable 模块处理文件。它基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径</p>
<h4 id="数据上传与安全">数据上传与安全</h4><ol>
<li><p>内存限制</p>
<ul>
<li>限制上传内容的大小，一旦超过限制，停止接收数据，并响应 400 状态码。通过 Content-Length 或 Buffer 长度判断</li>
<li>通过流式解析，将数据流导向磁盘中，Node 只保留文件路径等小数据</li>
</ul>
</li>
<li><p>CSRF<br> 全称 Cross-Site Request Forgery，即跨站请求伪造。用户在伪造网站 domain_b 提交表单到被攻击的站点 domain_a，则浏览器会将 domain_a 的 Cookie 发送到服务器，尽管请求来自 domain_b</p>
<p> 解决方法可以是页面渲染一个随机值并随表单一起提交，并在后台校验随机值是否一致</p>
</li>
</ol>
<h3 id="路由解析">路由解析</h3><h4 id="MVC">MVC</h4><p>MVC 模型工作模式如下：</p>
<ul>
<li>路由解析，根据 URL 寻找对应的控制器和行为</li>
<li>行为调用相关的模型，进行数据操作</li>
<li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端</li>
</ul>
<h5 id="手工映射">手工映射</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> routers = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> use = <span class="function"><span class="keyword">function</span>(<span class="params">path, action</span>) </span>&#123;</span><br><span class="line">    routes.push([path, action]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;routes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> route = routes[i];</span><br><span class="line">        <span class="keyword">if</span>(pathname === route[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">var</span> action = route[<span class="number">1</span>];</span><br><span class="line">            action(req, res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理 404 请求</span></span><br><span class="line">    handle404(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="正则匹配">正则匹配</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">use(<span class="string">'/profile/:username'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="自然映射">自然映射</h5><p>已约定的形式实现路由，而无需维护路由的映射。将路径划分处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/controller/action/param1/param2/param3</span><br><span class="line"><span class="comment">// =&gt; user/setting/12/1987</span></span><br></pre></td></tr></table></figure>
<p>自然映射这种路由方式在 PHP 的 MVC 框架 CodeIgniter 应用十分广泛。与手工映射相比，如果 URL 变动，它的文件也需要发生变动，手工映射只需要改变路由映射即可</p>
<h4 id="RESTful">RESTful</h4><p>全程 Representational State Transfer，即表现层状态转化。符合 REST 规范的设计，我们称为 RESTful 设计。它的设计哲学主要将服务器端提供的内容实体看做一个资源，并表现在 URL 上。通过 URL 设计资源，请求方法定义资源的操作，通过 Accept 决定资源的表现形式</p>
<h3 id="中间件">中间件</h3><p>引入中间件来简化和隔离基础设施与业务逻辑之间的细节，让开啊这能够关注在业务的开发上，已达到提升开发效率的目的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将中间件交给 handle 处理</span></span><br><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> middleware = stack.shift();</span><br><span class="line">        <span class="keyword">if</span>(middleware) &#123;</span><br><span class="line">            middleware(req, res, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 开始执行</span></span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="异常处理">异常处理</h4><p>为 next 添加 err 参数，并捕获中间件直接抛出的同步异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="keyword">return</span> handle500(err, req, res, stack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> middleware = stack.shift();</span><br><span class="line">        <span class="keyword">if</span>(middleware) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                middleware(req, res, next);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">                next(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 开始执行</span></span><br><span class="line">    next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以为进行异常处理的中间件提供四个参数，并与普通中间件区分开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, stack</span>) </span>&#123;</span><br><span class="line">    stack = stack.filter(<span class="function"><span class="keyword">function</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> middleware.length === <span class="number">4</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> middleware = stack.shift();</span><br><span class="line">        <span class="keyword">if</span>(middleware) &#123;</span><br><span class="line">            middleware(err, req, res, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="中间件与性能">中间件与性能</h5><ul>
<li><p><strong>编写高效的中间件</strong><br>  即提升单个处理单元的处理速度，尽早调用 next() 执行后续逻辑</p>
<ul>
<li>使用高效的办法，必要时使用 <a href="http://jsperf.com" target="_blank" rel="external">jsperf.com</a> 测试基准性能</li>
<li>缓存需要重复计算的结果（需要控制缓存用量）</li>
<li>避免不必要的计算，比如 HTTP 报文体的解析对 GET 方法无用</li>
</ul>
</li>
<li><strong>合理利用路由</strong><br>托管静态文件的中间件，可以通过添加路由路径，在不匹配路径的时候不会涉及该中间件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> staticFile = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">    </span><br><span class="line">    fs.readFile(path.join(ROOT, pathname), <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="keyword">return</span> next();</span><br><span class="line">        &#125;</span><br><span class="line">        res.writeHead(<span class="number">200</span>);</span><br><span class="line">        res.end(file);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/public'</span>, staticFile);</span><br></pre></td></tr></table></figure>
<h3 id="页面渲染">页面渲染</h3><h4 id="内容响应">内容响应</h4><p>浏览器通过 Content-Type 决定采用不同的渲染方式，这些值简称 MIME。其全称是 Multipurpose Internet Mail Extensions，最早用于电子邮件，后来也应用到浏览器中。不同文件类型具有不同的 MIME 值</p>
<table>
<thead>
<tr>
<th>类选</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTML</td>
<td>text/html</td>
</tr>
<tr>
<td>TXT</td>
<td>text/plain</td>
</tr>
<tr>
<td>JSON</td>
<td>application/json</td>
</tr>
<tr>
<td>XML</td>
<td>application/xml</td>
</tr>
<tr>
<td>PNG</td>
<td>image/png</td>
</tr>
</tbody>
</table>
<p>Content-Type 后还可以包含一些参数，如字符集</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: <span class="string">text-javascript; charset=utf-8</span></span><br></pre></td></tr></table></figure>
<h5 id="附件下载">附件下载</h5><p>Content-Disposition 字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时浏览时，它的值为 inline；当数据可以存为附件时，它的值为 attachment。另外，可以通过参数指定保存时应该使用的文件名</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span>: <span class="string">attachment; filename="file.txt"</span></span><br></pre></td></tr></table></figure>
<h5 id="响应跳转">响应跳转</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.direct = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Location'</span>, url);</span><br><span class="line">    res.writeHead(<span class="number">302</span>);</span><br><span class="line">    res.end(<span class="string">'Ridirect to '</span> + url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="视图渲染">视图渲染</h4><p>模板包括以下四个要素</p>
<ul>
<li>模板语言</li>
<li>包含模板语言的模板文件</li>
<li>拥有动态数据的数据对象</li>
<li>模板引擎</li>
</ul>
<p>其中，模板引擎氛围以下几个步骤</p>
<ul>
<li>语法分解。提取出普通字符串和表达式，这个过程通常由正则表达式匹配</li>
<li>处理表达式。将标签表达式转换为普通的语言表达式</li>
<li>生成待执行的语句</li>
<li>与数据一起执行，生成最终字符串</li>
</ul>
<h3 id="Bigpipe">Bigpipe</h3><p>允许将页面分割为多个部分，先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个页面的渲染</p>
<p>这是一个需要前后端配合实现的优化技术，有几个重要的点</p>
<ul>
<li>页面布局框架（无数据）</li>
<li>后端持续性的数据输出</li>
<li>前端渲染</li>
</ul>
<h4 id="页面布局">页面布局</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"body"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/template"</span> <span class="attribute">id</span>=<span class="value">"tpl_body"</span>&gt;</span><span class="handlebars"><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">%=</span> <span class="attribute">articles</span> %&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">    <span class="keyword">var</span> bigpipe = <span class="keyword">new</span> Bigpipe();</span><br><span class="line">    bigpipe.ready(<span class="string">'articles'</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span><br><span class="line">        render(data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="持续数据输出">持续数据输出</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ep = <span class="keyword">new</span> EventProxy();</span><br><span class="line"></span><br><span class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">res.write(render(compile(layout)));</span><br><span class="line"></span><br><span class="line">ep.all(<span class="string">'users'</span>, <span class="string">'articles'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">ep.fail(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line">ep.getData(<span class="string">'sql1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    data = err ? &#123;&#125; : data;</span><br><span class="line">    res.write(<span class="string">'&lt;script&gt;bigpipe.set(articles, '</span> + <span class="built_in">JSON</span>.stringify(data) + <span class="string">');&lt;/script&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ep.getData(<span class="string">'sql2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    data = err ? &#123;&#125; : data;</span><br><span class="line">    res.write(<span class="string">'&lt;script&gt;bigpipe.set(users, '</span> + <span class="built_in">JSON</span>.stringify(data) + <span class="string">');&lt;/script&gt;'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="前端渲染">前端渲染</h4><p>bigpipe.ready() 和 bigpipe.set() 是整个前端的渲染机智。前者注册一个事件，后者触发一个事件</p>
<p>Bigpipe 将页面布局和数据渲染分离，随着数据输出的过程逐步渲染页面。通过 Ajax 也能完成，但 Ajax 背后是 HTTP 调用，消耗更多的网络连接</p>
<h2 id="玩转进程">玩转进程</h2><h3 id="多进程架构">多进程架构</h3><h4 id="创建子进程">创建子进程</h4><p>child_process 模块提供创建子进程的方法</p>
<ul>
<li>spawn()：启动一个子进程来执行命令</li>
<li>exec()：启动一个子进程来执行命令，与 spawn() 不同的是它有一个回调函数获知子进程的状况</li>
<li>execFile()：启动一个子进程来执行可执行文件</li>
<li>fork()：与 spawn() 类似，不同点在于它创建 Node 的子进程只需指定要执行的 Javascript 文件模块即可</li>
</ul>
<p>执行 work.js 的示例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line">cp.spawn(<span class="string">'node'</span>, [<span class="string">'work.js'</span>]);</span><br><span class="line"></span><br><span class="line">cp.exec(<span class="string">'node worker.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cp.execFile(<span class="string">'work.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">cp.fork(<span class="string">'./work.js'</span>);</span><br></pre></td></tr></table></figure>
<p>创建子进程之后将返回子进程对象，差别如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:center">回调/异常</th>
<th style="text-align:center">进程类型</th>
<th style="text-align:center">执行类型</th>
<th style="text-align:center">可设置超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>spawn()</td>
<td style="text-align:center">否</td>
<td style="text-align:center">任意</td>
<td style="text-align:center">命令</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>exec()</td>
<td style="text-align:center">是</td>
<td style="text-align:center">任意</td>
<td style="text-align:center">命令</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>execFile()</td>
<td style="text-align:center">是</td>
<td style="text-align:center">任意</td>
<td style="text-align:center">可执行文件</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>fork()</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Node</td>
<td style="text-align:center">Javascript 文件</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>如果希望通过 execFile 执行 Javascript 文件，则需要在首行添加如下代码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!usr/bin/env node</span><br></pre></td></tr></table></figure>
<h4 id="进程间通信">进程间通信</h4><p>浏览器中，Javascript 主线程与 UI 渲染共用同一个线程，执行 Javascript 和渲染 UI 两者互相阻塞。HTML5 提出了 WebWorker API，允许创建工作线程在后台运行。在 Node 中主线程与工作线程之间的通信与 worker 类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">var</span> n = cp.fork(__dirname + <span class="string">'/sub.js'</span>);</span><br><span class="line"></span><br><span class="line">n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'receive: '</span> + m);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">n.send(&#123;hello: <span class="string">'world'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub.js</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child receive: '</span> + m);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.send(&#123;foo: <span class="string">'bar'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>父进程与子进程通过 UPC 通道传递消息。IPC 全程是 InterProcess Communication，即进程间通信。父进程在实际创建子进程钱，会创建 IPC 通道并监听它，然后创建出子进程，告知子进程 IPC 通道的文件描述符，子进程在启动过程中通过文件描述符去连接已存在的 IPC 通道，从而完成父子进程间的连接</p>
<h4 id="句柄传递">句柄传递</h4><p>句柄指一种可以用来标识资源的引用，其内部包含了指向对象的文件描述符。Node 允许进程间发送句柄</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父进程</span></span><br><span class="line"><span class="keyword">var</span> child0 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">'child.js'</span>);</span><br><span class="line"><span class="keyword">var</span> server  = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">1137</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    child0.send(<span class="string">'server'</span>, server);</span><br><span class="line">    child1.send(<span class="string">'server'</span>, server);</span><br><span class="line">    server.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子进程</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'handle by child: '</span> + process.pid);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m === <span class="string">'server'</span>) &#123;</span><br><span class="line">        tcp.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">            server.emit(<span class="string">'connection'</span>, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在发送完句柄并关闭监听之后，多个子进程可以同时监听相同端口而不会抛出异常，理由在于向子进程发送句柄后，多个子进程可以拿到相同 TCP 服务器端 socket 套接字的文件描述符，因此能够同时监听相同端口不会引起异常。而文件描述符同一时间只能被某个进程引用，也就是说一个请求只能被一个进程处理，切这种进程服务是抢占式的</p>
<p>此外，发送句柄尽管看起来像是把 server 对象发送给子进程，实际上只传递了我们要发送的句柄文件描述符。Node 进程间只有消息传递，不会传递真正的对象，发送句柄的使用是抽象封装的结果</p>
<p>目前子进程对象 send() 方法允许发送的句柄类型如下几种</p>
<ul>
<li>net.Socket：TCP 套接字</li>
<li>net.Server：Tcp 服务器</li>
<li>net.Native：C++ 层面的 TCP 套接字 或 IPC 通道</li>
<li>dgram.Socket：UDP 套接字</li>
<li>dgram.Native：C++ 层面的 UDP 套接字</li>
</ul>
<h3 id="集群">集群</h3><h4 id="进程事件">进程事件</h4><p>子进程对象除了 send() 方法和 message 事件歪，还有如下事件</p>
<ul>
<li>error：当子进程无法被复制创建、无法被杀死、无法发送消息时触发</li>
<li>exit：子进程退出时触发该事件。子进程如果正常退出，则第一个参数为退出码，否则为 null。如果子进程是通过 kill() 方法杀死，则得到第二个参数，表示杀死进程时的信号</li>
<li>close：在子进程的标准输入输出流终止时触发该事件，参数与 exit 相同</li>
<li>disconnect：在父进程或子进程中调用 disconnect() 方法时触发，调用该方法将关闭监听 IPC 通道</li>
<li><p>kill：允许父进程向子进程发送系统信号杀掉子进程，或者子进程自杀</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child.kill([signal]);</span><br><span class="line"></span><br><span class="line">process.kill(pid, [signal]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关于 kill 信号，常用有如下几个</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>编号</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>HUP</td>
<td>1</td>
<td style="text-align:left">终端断线</td>
</tr>
<tr>
<td>INT</td>
<td>2</td>
<td style="text-align:left">中断（同 Ctrl + C）</td>
</tr>
<tr>
<td>QUIT</td>
<td>3</td>
<td style="text-align:left">退出（同 Ctrl + \）</td>
</tr>
<tr>
<td>TERM</td>
<td>5</td>
<td style="text-align:left">终止</td>
</tr>
<tr>
<td>KILL</td>
<td>9</td>
<td style="text-align:left">强制终止</td>
</tr>
<tr>
<td>CONT</td>
<td>8</td>
<td style="text-align:left">继续（与STOP相反， fg/bg命令）</td>
</tr>
<tr>
<td>STOP</td>
<td>9</td>
<td style="text-align:left">暂停（同 Ctrl + Z）</td>
</tr>
</tbody>
</table>
<h4 id="自动重启">自动重启</h4><p>父进程创建子进程时，子进程监听 exit 事件，在退出时触发创建新的子进程即可</p>
<p>然而上述存在的问题是，子进程只有在断开所有连接之后才会退出。因此可以调整为子进程在抛出未捕获异常时，向父进程发送自杀消息，父进程便可以在子进程退出之前创建新的子进程</p>
<p>如果多次出现未捕获异常，有必要收集异常日志并发出警报。也可以添加计数器，检查是否频繁重启，有利于及时发现问题所在</p>
<h4 id="负载均衡">负载均衡</h4><p>在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，而保证多个处理单元工作量公平的策略叫做负载均衡。Node 默认提供的机制是采用操作系统的抢占式策略</p>
<p>然而 Node 的繁忙需要分清 CPU 和 I/O，可能造成负衡不均匀的情况</p>
<p>为此 Node 在 v0.11 中提供了一种新的侧咧 Round-Robin，又叫伦叫调度。由主进程接受连接，将其一次分发给工作进程。在 cluster 模块中启用它的方式是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_RR</span><br><span class="line"><span class="comment">// 不启用</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE</span><br></pre></td></tr></table></figure>
<h4 id="状态共享">状态共享</h4><p>由于 Node 进程间无法共享数据，所以是欧诺个第三方来进行数据存储是最简单直接的方式</p>
<p>实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询，带来的问题显而易见；另一种是主动通知，即当数据发生更新时，主动通知子进程，这个过程仍然不能脱轮询，但可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫通知进程</p>
<h3 id="Clustor_模块">Clustor 模块</h3><p>v0.8 引入了 cluster 模块用于解决多核 cpu 的利用率问题，同时提供了完善的 API，用以处理进程的健壮性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cluster.js</span></span><br><span class="line"><span class="keyword">var</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">    exec: <span class="string">'worker.js'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cups();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;cpus.length; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过环境变量中是否有 NODE_UNIQUE_ID 判断是主进程还是工作进程</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cluster.isWorker = (<span class="string">'NODE_UNIQUE_ID'</span> <span class="keyword">in</span> process.env);</span><br><span class="line">cluster.isMaster = (cluster.isWorker === <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="工作原理">工作原理</h4><p>cluster 模块是 child_process 和 net 模块的组合应用，其内部创建 TCP 服务器的方式对使用者来说十分透明，但也由此使得一个进程只能管理一组工作进程，无法向 child_process 那么灵活</p>
<h4 id="Cluster_事件">Cluster 事件</h4><ul>
<li>fork：复制一个工作进程后触发该事件</li>
<li>online：复制好一个工作进程后，工作进程主动发送一条 online 消息给主线程，主线程收到消息后触发该事件</li>
<li>listening：工作进程中调用 listen()（共享了服务器端 socket）后，发送一条 listening 消息给主进程，主进程收到消息后触发该事件</li>
<li>disconnect：主进程和工作进程之间 IPC 通道断开后会触发该事件</li>
<li>exit：有工作进程退出时触发该事件</li>
<li>setup：cluster.setMaster() 执行后触发该事件</li>
</ul>
<h2 id="测试">测试</h2><h3 id="单元测试介绍">单元测试介绍</h3><h4 id="断言">断言</h4><p>Javascript 的断言规范最早来自于 CommonJS 的单元测试，Node 实现了规范中的断言部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line">assert.equal(<span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">100</span>), <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>断言规范中定义了以下几种检测方法</p>
<ul>
<li>ok()：判断结果是否为真</li>
<li>equal()：判断实际值与期望值是否相同</li>
<li>notEqual()：判断实际值与期望值是否不相同</li>
<li>deepEqual()：判断实际值与期望值是否深度相同（对象或数组的元素是否相等）</li>
<li>notDeepEqual()：判断实际值与期望值是否不深度相等</li>
<li>strictEqual()：判断实际值与期望值是否严格相等（相当于 ===）</li>
<li>notStrictEqual()：判断实际值与期望值是否不严格相等（相当于 !==）</li>
<li>throws()：判断代码块是否抛出异常</li>
</ul>
<p>除此之外，Node 的 assect 模块还扩展了如下两个断言方法</p>
<ul>
<li>doesNotThrow()：判断代码块是否没有抛出异常</li>
<li>ifError()：判断实际值是否为一个假值（null、 undefined、 0、 ‘’、 false），如果实际值为真值，则抛出异常</li>
</ul>
<h4 id="测试框架">测试框架</h4><p>测试框架能记录下抛出的异常并继续执行，最后生成测试报告。其为用于为测试服务，本身不参与测试。这里介绍 mocha</p>
<p>陷阱流星的单元测试风格主要由 TDD（测试驱动开始）和 BDD（行为驱动开发）两种（wiki 显示其属于开发方法）。前者从功能的角度上设计测试用例，主要由开发人员引导；后者从自然行为的角度设计测试用例，鼓励非研发人员参与</p>
<p>mocha 支持上述两种风格，提供不同的关键字</p>
<p>mocha 提供不同的测试报告格式，通过<code>mocha --reporters</code>可查看所有支持的格式。可将结果传递给其他程序处理，而<code>html-cov</code>可用于可视化观察代码覆盖率</p>
<p>简单的 TDD 风格的测试用例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">suite(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    test(<span class="string">'should return -1 when not present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        assert.equal(-<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">4</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    test(<span class="string">'should return index when present'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        assert.equal(<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">1</span>));</span><br><span class="line">        assert.equal(<span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">2</span>));</span><br><span class="line">        assert.equal(<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">3</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="异步测试">异步测试</h4><p>通过参数长度判断是否异步测试</p>
<p>BDD 风格的异步测试用例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">'fs.fileFile should be ok'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file_path'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        should.not.exist(err);</span><br><span class="line">        done();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="超时设置">超时设置</h4><p>可以在测试用例<code>it</code>中通过 this.timeout(s) 实现对单个用例的特殊设置，也可以在描述 describe 中调用 this.timeout(s) 设置描述下当前层级的所有用例</p>
<h4 id="测试覆盖率">测试覆盖率</h4><p>可以通过 jscover 或者 blanket 模块报告测试覆盖率，前者通过 Java 实现，编译之后在每行代码前插入统计代码再执行，后者由 js 实现，原理与前者相同。这里介绍 blanket</p>
<p>使用 blanket 报告代码覆盖率需要在所有测试用例运行之前通过 –require 选项引入它既可</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mocha --require blanket -R html-cov &#62; coverage.html</span><br></pre></td></tr></table></figure>
<p>另外，需要在包描述文件中配置 scripts 节点。在 scripts 节点中，pattern 属性用以匹配需要编译的文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"script"</span>: &#123;</span><br><span class="line">    <span class="string">"blanket"</span>: &#123;</span><br><span class="line">        <span class="string">"pattern"</span>: <span class="string">"eventproxy/lib"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mock">mock</h4><p>模拟异常较难实现，称为 mock。看可以通过伪造被调用方来测试上层代码的健壮性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'getContent'</span>. <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _readFileSync;</span><br><span class="line">    before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _readFileSync = fs.readFileSync;</span><br><span class="line">        fs.readFileSync = <span class="function"><span class="keyword">function</span>(<span class="params">filename, encoding</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'mock readFileSync error'</span>)<span class="string">''</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// it()</span></span><br><span class="line">    after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fs.readFileSync = _readFileSync;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>相当于猴子补丁，也可以通过 muk 模块帮忙</p>
<p>同时，对于异步方法的模拟，需要小心是否将异步方法模拟为同步。通过 process.nextTick() 辅助即可</p>
<h4 id="私有方法的测试">私有方法的测试</h4><p>除了 exports 导出的属性和方法，其他私有方法难以测试。可通过 rewire 实现对私有方法的测试</p>
<h4 id="工程化与自动化">工程化与自动化</h4><p>通过 Makefile 完成自动化编译，通过 travis-ci 解决持续集成</p>
<h3 id="性能测试">性能测试</h3><p>基准测试要统计在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此判别性能的差距</p>
<h3 id="压力测试">压力测试</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ ab -c 10 -t 3 http://127.0.0.1/&#10;This is ApacheBench, Version 2.3 &#60;$Revision: 1663405 $&#62;&#10;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/&#10;Licensed to The Apache Software Foundation, http://www.apache.org/&#10;&#10;Benchmarking 127.0.0.1 (be patient)&#10;Completed 5000 requests&#10;Completed 10000 requests&#10;Completed 15000 requests&#10;Finished 15301 requests&#10;&#10;&#10;Server Software:        &#10;Server Hostname:        127.0.0.1&#10;Server Port:            80&#10;&#10;Document Path:          /&#10;Document Length:        16 bytes&#10;&#10;Concurrency Level:      10&#10;Time taken for tests:   3.000 seconds&#10;Complete requests:      15301&#10;Failed requests:        0&#10;Total transferred:      1882023 bytes&#10;HTML transferred:       244816 bytes&#10;Requests per second:    5100.31 [#/sec] (mean)&#10;Time per request:       1.961 [ms] (mean)&#10;Time per request:       0.196 [ms] (mean, across all concurrent requests)&#10;Transfer rate:          612.64 [Kbytes/sec] received&#10;&#10;Connection Times (ms)&#10;              min  mean[+/-sd] median   max&#10;Connect:        0    0   1.1      0     136&#10;Processing:     1    2   3.5      2     137&#10;Waiting:        1    2   3.5      2     137&#10;Total:          1    2   3.6      2     137&#10;&#10;Percentage of the requests served within a certain time (ms)&#10;  50%      2&#10;  66%      2&#10;  75%      2&#10;  80%      2&#10;  90%      2&#10;  95%      2&#10;  98%      4&#10;  99%      5&#10; 100%    137 (longest request)</span><br></pre></td></tr></table></figure>
<h4 id="基准测试驱动开发">基准测试驱动开发</h4><ol>
<li>写基准测试</li>
<li>写/改代码</li>
<li>收集数据</li>
<li>找出问题</li>
<li>回到第 2 步</li>
</ol>
<h4 id="测试数据与业务数据的转换">测试数据与业务数据的转换</h4><p>根据实际业务评估业务量，计算公式为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">QPS = PV / diration</span><br></pre></td></tr></table></figure>
<h2 id="产品化">产品化</h2><h3 id="项目工程化">项目工程化</h3><h4 id="构建工具">构建工具</h4><ul>
<li>Makefile：*nix 系统下经典的构建工具。依托强大的 bash 编程，通常用来管理一些编译相关的工作</li>
<li>Grunt：依托丰富的插件，自身提供通用接口用于插件的接入，具体的任务由插件完成</li>
</ul>
<h4 id="编码规范">编码规范</h4><p>通过文档式的约定和代码提交时的强制检查实现</p>
<h4 id="代码审查">代码审查</h4><p>主要在请求合并的过程中完成，需要审查功能是否正确完成、编码风格是否符合规范、单元测试是否同步添加</p>
<h4 id="部署流程">部署流程</h4><p>部署操作中，可能会用到 nohup 和 &amp; 以不挂断的方式让进程持续执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nohup node app.js &amp;</span><br></pre></td></tr></table></figure>
<p>停止和重启进程则比启动进程复杂一点，可通过 bash 脚本实现。主进程在启动时将进程 ID 写入一个 pid 文件，以此通过脚本管理进程</p>
<h4 id="性能">性能</h4><ul>
<li>动静分离<br>  将动态请求和静态请求分离后，服务器可以专注动态服务方面，CDN 托管静态文件能够有更精确和高效的缓存机制，而且不同域名能消除不必要的 Cookie 传输和浏览器对下载线程数的限制</li>
<li>启用缓存</li>
<li>多进程架构</li>
<li>读写分离</li>
</ul>
<h4 id="日志">日志</h4><ul>
<li><p>访问日志<br>  一般用来记录每个客户端所对应的访问。在 Web 应用中，主要记录 HTTP 请求中的关键数据</p>
</li>
<li><p>异常日志<br>  通常用来记录那些意外产生的异常错误。通过日志的记录，能够较快地定位问题所在。console 对象上具有一个 Console 属性，是 console 对象的构造函数。借助这个构造函数，可以实现自己的日志对象。代码如下：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> info = fs.createWriteStream(logdir + <span class="string">'/info.log'</span>, &#123;flags: <span class="string">'a'</span>, mode: <span class="string">'0666'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> error = fs.createWriteStream(logdir + <span class="string">'/error.log'</span>, &#123;flags: <span class="string">'a'</span>, mode: <span class="string">'0666'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logger =  <span class="keyword">new</span> <span class="built_in">console</span>.Console(info, error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">logger.log(<span class="string">'hello'</span>);</span><br><span class="line">logger.errer(<span class="string">'fault'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常处理<br>  开发者应该当将 API 内部发生的异常座位第一个实参传递给回调函数。对于回调函数中产生的异常，则交给全局的 uncaughtException 事件去捕获即可</p>
<p>  在逐层次的异步 API 调用中，建议将异常交给最上层的调用者捕获记录，底层调用或中间层调用中出现的异常只要正常传递给上方德调用方即可</p>
</li>
<li><p>日志与数据库<br>  日志文件与数据库写入在性能上处于两个级别，数据库在写入过程中药经历一系列处理，比如锁表、日志等操作；写日志文件则是将数据直接写到磁盘上。如果有大量访问，可能存在写入操作大量排队的问题，数据库的消费速度严重低于生产速度，进而导致内存泄露</p>
</li>
</ul>
<h3 id="监控报警">监控报警</h3><ul>
<li>日志监控</li>
<li>响应时间</li>
<li>进程监控</li>
<li>磁盘监控</li>
<li>内存监控</li>
<li>CPU 占用监控</li>
<li>CPU load 监控</li>
<li>I/O 监控</li>
<li>网络监控</li>
<li>应用状态监控</li>
<li>DNS 监控</li>
</ul>
<h3 id="稳定性">稳定性</h3><ul>
<li>多机器</li>
<li>多机房</li>
<li>容灾备份</li>
</ul>
<h3 id="异构共存">异构共存</h3><p>在应用 Node 的过程中，不存在为了用它而推翻已有设计的情况。Node  能够通过协议与已有的系统很好地异构共存</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/cif86yq51000jtuqci2afp3mh/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          模板引擎
        
      </div>
    </a>
  
  
    <a href="/cif86yq74001ktuqce1lmz8gl/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">jQuery技术内幕</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 liyh
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-67000695-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>