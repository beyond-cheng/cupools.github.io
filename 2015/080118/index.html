<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 正则表达式 · 一环的笔记</title><meta name="description" content="正则表达式 - liyh"><meta name="description" content="还是稍微做个笔记吧，感觉会很有帮助。Javascript 的正则表达式实现与这里存在差异_(:з」∠)_">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="http://cupools.github.io/2015/080118/index.html">
<meta property="og:site_name" content="一环的笔记">
<meta property="og:description" content="还是稍微做个笔记吧，感觉会很有帮助。Javascript 的正则表达式实现与这里存在差异_(:з」∠)_">
<meta property="og:updated_time" content="2016-08-26T14:12:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="正则表达式">
<meta name="twitter:description" content="还是稍微做个笔记吧，感觉会很有帮助。Javascript 的正则表达式实现与这里存在差异_(:з」∠)_"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://cupools.github.io/atom.xml" title="一环的笔记"></head><body><div class="wrap"><header><a href="/" class="logo-link">EXPORT DEFAULT LIYH</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/cupools" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:cupools@gmail.com" target="_self" class="nav-list-link">GMAIL</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">正则表达式</h1><div class="post-info">Aug 1, 2015<ul class="post-tag-list"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul></div><div class="post-content"><p>还是稍微做个笔记吧，感觉会很有帮助。Javascript 的正则表达式实现与这里存在差异_(:з」∠)_</p>
<a id="more"></a>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody>
</table>
<p>元字符 <code>\b</code>，<code>^</code> 和 <code>$</code> 都匹配一个位置。如果允许处理多行，则 <code>^</code> 和 <code>$</code> 的意义变为匹配行的开始处和结束处</p>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>查找元字符本身需要使用 <code>\</code> 转义，如 <code>\\</code>，<code>\.</code> 等</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><table>
<thead>
<tr>
<th>代码 / 语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复 n 或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复 n 到 m 次</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">// 匹配 window 后面跟一个或多个数字</div><div class="line">/window\d+/</div><div class="line"></div><div class="line">// 匹配第一个单词</div><div class="line">/^\w+/</div></pre></td></tr></table></figure>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>在方括号中列出字符集合可指定字符范围</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 元音字母</span></div><div class="line">/[aeiou]/</div><div class="line"></div><div class="line"><span class="comment">// 英文字母及数字</span></div><div class="line">/[a-z0<span class="number">-9</span>A-Z]/</div></pre></td></tr></table></figure>
<h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>使用 <code>|</code> 将不同的规则分隔开，如果满足其中任意一种规则就当做匹配。满足一种规则后将忽略后面的规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 美国邮编</span></div><div class="line">/d&#123;<span class="number">5</span>&#125;-d&#123;<span class="number">4</span>&#125;|d&#123;<span class="number">5</span>&#125;/</div></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>重复多个字符，可以用小括号指定<strong>子表达式</strong>（分组）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 匹配 hahaha</span></div><div class="line">/(ha)&#123;<span class="number">3</span>&#125;/</div><div class="line"></div><div class="line"><span class="comment">// 匹配 IP 地址</span></div><div class="line">/((<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|[<span class="number">01</span>]?\d\d?)\.)&#123;<span class="number">3</span>&#125;(<span class="number">2</span>[<span class="number">0</span><span class="number">-4</span>]\d|<span class="number">25</span>[<span class="number">0</span><span class="number">-5</span>]|[<span class="number">01</span>]?\d\d?)/</div></pre></td></tr></table></figure>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><table>
<thead>
<tr>
<th>代码 / 语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td>匹配任意非字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意非空字符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>匹配除字符集 [xyz] 以外的字符</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">// 匹配不包含空白符的字符串</div><div class="line">/\S+/</div><div class="line"></div><div class="line">// 匹配尖括号括起来的以 a 开头的字符串</div><div class="line">/&lt;a[^&gt;]+&gt;/</div></pre></td></tr></table></figure>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。具体如下：</p>
<ul>
<li>分组0对应整个正则表达式</li>
<li>组号分配过程需要从左向右扫描两遍：第一遍只给未命名组分配，第二遍只给命名组分配。因此所有命名组的组号都大于未命名的组号</li>
<li>可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权</li>
</ul>
<p>后向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本</p>
<p>也可以通过<code>(?&lt;name&gt;\w+)</code>或者<code>(?&#39;name&#39;\w+)</code>指定组名，通过 <code>\k&lt;name&gt;</code> 反向引用。<strong>Javascript 不支持</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 匹配重复的单词，如 "ha ha"</span></div><div class="line">/\b(\w+)\b\s+\<span class="number">1</span>\b/</div><div class="line"></div><div class="line"><span class="comment">// 等效于</span></div><div class="line">/(?&lt;words&gt;\w+)\b\s+\k&lt;words&gt;\b)/</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>类型</th>
<th>代码 / 语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>捕获</td>
<td>(exp)</td>
<td>匹配 exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>(?\<name\>exp)</name\></td>
<td>匹配 exp,并捕获文本到名称为 name 的组里，也可以写成 (?’name’exp)</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>(?:exp)</td>
<td>匹配 exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
<tr>
<td>零宽断言</td>
<td>(?=exp)</td>
<td>匹配 exp 前面的位置</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>(?&lt;=exp)</td>
<td>匹配 exp 后面的位置</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>(?!exp)</td>
<td>匹配后面跟的不是 exp 的位置</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>(?&lt;!exp)</td>
<td>匹配前面不是 exp 的位置</td>
</tr>
<tr>
<td>注释</td>
<td>(?#comment)</td>
<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>
</tr>
</tbody>
</table>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>零宽断言用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像<code>\b</code>,<code>^</code>,<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件(即断言)</p>
<h5 id="exp"><a href="#exp" class="headerlink" title="(?=exp)"></a>(?=exp)</h5><p><strong>零宽度正预测先行断言</strong>，它断言自身出现的位置的后面能匹配表达式 exp。比如 <code>\b\w+(?=ing\b)</code>，匹配以 “ing” 结尾的单词的前面部分(除了 “ing “以外的部分)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 匹配以 "ing" 结尾的单词的前面部分</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">"I'm singing while you're dancing"</span>,</div><div class="line">    reg = <span class="regexp">/\b\w+(?=ing)/g</span>;</div><div class="line"></div><div class="line">str.match(reg);	<span class="comment">// =&gt; ["sing", "danc"]</span></div></pre></td></tr></table></figure>
<h5 id="lt-exp"><a href="#lt-exp" class="headerlink" title="(?&lt;=exp)"></a>(?&lt;=exp)</h5><p><strong>零宽度正回顾后发断言</strong>，它断言自身出现的位置的前面能匹配表达式 exp。<strong>Javascript 不支持</strong></p>
<p>比如<code>(?&lt;=\bre)\w+\b</code>会匹配以 “re” 开头的单词的后半部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="string">'Please resize the viewport'</span></div><div class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=\bre)\w+\b</span>/</span></span></div><div class="line">=&gt; "size"</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 匹配不包含属性的简单 HTML 标签内的内容</span></div><div class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=</span>&lt;(\<span class="attr">w</span>+)&gt;</span>).*(?=<span class="tag">&lt;<span class="name">\</span>/\<span class="attr">1</span>&gt;</span>)/</span></div></pre></td></tr></table></figure>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="(?!exp)"></a>(?!exp)</h5><p><strong>零宽度负预测先行断言</strong>，断言此位置的后面不能匹配表达式 exp</p>
<p>比如<code>\d{3}(?!\d)</code>匹配三位数字，而且这三位数字的后面不能是数字；<code>\b((?!abc)\w)+\b</code>匹配不包含连续字符串abc的单词</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 匹配不包含 "ing" 的单词</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">"singing and dancing"</span>,</div><div class="line">    reg = <span class="regexp">/\b((?!ing)\w)+\b/g</span>;</div><div class="line"></div><div class="line">str.match(reg);	<span class="comment">// =&gt; ["and"]</span></div><div class="line"></div><div class="line"><span class="comment">// 发现这样子无法匹配</span></div><div class="line">reg = <span class="regexp">/\b(?!ing)\w+\b/g</span>;</div><div class="line">str.match(reg); <span class="comment">// =&gt; ["singing", "and", "dancing"]</span></div></pre></td></tr></table></figure>
<h5 id="lt-exp-1"><a href="#lt-exp-1" class="headerlink" title="(?&lt;!exp)"></a>(?&lt;!exp)</h5><p><strong>零宽度负回顾后发断言</strong>，断言此位置的前面不能匹配表达式 exp。<strong>Javascript 不支持</strong></p>
<p>比如<code>(?&lt;![a-z])\d{7}</code>匹配前面不是小写字母的七位数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="string">'Please resize the viewport'</span></div><div class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">!\bre)\w+\b</span>/</span></span></div><div class="line">=&gt; ["PLease", "the", "viewport"]</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>通过语法<code>(?#comment)</code>来包含注释</p>
<p>例如：<code>2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</code></p>
<p>如果启用忽略模式里的空白字符，可以在编写表达式时能任意的添加空格，Tab，换行。可以这样写代码</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">(?&lt;=    # 断言要匹配的文本的前缀</div><div class="line">&lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)</div><div class="line">)       # 前缀结束</div><div class="line">.*      # 匹配任意文本</div><div class="line">(?=     # 断言要匹配的文本的后缀</div><div class="line">&lt;\/\1&gt;  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签</div><div class="line">)       # 后缀结束</div></pre></td></tr></table></figure>
<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><h4 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h4><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。</p>
<p><code>a.*b</code>，它将会匹配最长的以 “a” 开始，以 “b” 结束的字符串。如果用它来搜索 “aabab” 的话，它会匹配整个字符串 “aabab”。</p>
<h4 id="懒惰匹配"><a href="#懒惰匹配" class="headerlink" title="懒惰匹配"></a>懒惰匹配</h4><p>也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<p><code>a.*?b</code>匹配最短的，以 “a” 开始，以 “b” 结束的字符串。如果把它应用于 “aabab” 的话，它会匹配 “aab”（第一到第三个字符）和 “ab”（第四到第五个字符）</p>
<p>为什么第一个匹配是 “aab”（第一到第三个字符）而不是 “ab”（第二到第三个字符）？简单地说，因为<strong>正则表达式有另一条规则，比懒惰 / 贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权</strong></p>
<table>
<thead>
<tr>
<th>代码 / 语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><table>
<thead>
<tr>
<th>代码 / 语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IgnoreCase</td>
<td>匹配时不区分大小写</td>
</tr>
<tr>
<td>Multiline</td>
<td>更改<code>^</code>和<code>$</code>的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,<code>$</code>的精确含意是:匹配<code>\n</code>之前的位置以及字符串结束前的位置.)</td>
</tr>
<tr>
<td>Singleline</td>
<td>更改<code>.</code>的含义，使它与每一个字符匹配（包括换行符<code>\n</code>）</td>
</tr>
<tr>
<td>IgnorePatternWhitespace</td>
<td>忽略表达式中的非转义空白并启用由<code>#</code>标记的注释</td>
</tr>
<tr>
<td>ExplicitCapture</td>
<td>仅捕获已被显式命名的组</td>
</tr>
</tbody>
</table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>代码 / 语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>报警字符(打印它的效果是电脑嘀一声)</td>
</tr>
<tr>
<td>\b</td>
<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，Tab</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\v</td>
<td>竖向制表符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape</td>
</tr>
<tr>
<td>\0nn</td>
<td>ASCII 代码中八进制代码为 nn 的字符</td>
</tr>
<tr>
<td>\xnn</td>
<td>ASCII 代码中十六进制代码为 nn 的字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>Unicode 代码中十六进制代码为 nnnn 的字符</td>
</tr>
<tr>
<td>\cN</td>
<td>ASCII 控制字符。比如 \cC 代表 Ctrl+C</td>
</tr>
<tr>
<td>\A</td>
<td>字符串开头(类似 ^，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\Z</td>
<td>字符串结尾或行尾(不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\z</td>
<td>字符串结尾(类似 $，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\G</td>
<td>当前搜索的开头</td>
</tr>
<tr>
<td>\p{name}</td>
<td>Unicode 中命名为 name 的字符类，例如 \p{IsGreek}</td>
</tr>
<tr>
<td>(?&gt;exp)</td>
<td>贪婪子表达式</td>
</tr>
<tr>
<td>(?<x>-<y>exp)</y></x></td>
<td>平衡组</td>
</tr>
<tr>
<td>(?im-nsx:exp)</td>
<td>在子表达式exp中改变处理选项</td>
</tr>
<tr>
<td>(?im-nsx)</td>
<td>为表达式后面的部分改变处理选项</td>
</tr>
<tr>
<td>(?(exp)yes/no)</td>
<td>把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no</td>
</tr>
<tr>
<td>(?(exp)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
<tr>
<td>(?(name)yes/no)</td>
<td>如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no</td>
</tr>
<tr>
<td>(?(name)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
</tbody>
</table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a></p>
<h6 id="小记：一遍吃下来收获很多哟"><a href="#小记：一遍吃下来收获很多哟" class="headerlink" title="小记：一遍吃下来收获很多哟"></a>小记：一遍吃下来收获很多哟</h6></div></article></div></section><footer><div class="paginator"><a href="/2015/081023/" class="prev">PREV</a><a href="/2015/080121/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 <a href="http://cupools.github.io">liyh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-67000695-1",'auto');ga('send','pageview');</script></body></html>