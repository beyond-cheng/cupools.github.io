<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>深入浅出NodeJS | (&lt;ゝω·)Kira☆~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="模块机制CommonJS 规范模块引用var math = require(&apos;math&apos;);
CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出NodeJS">
<meta property="og:url" content="http://yoursite.com/2015/08/07/books/深入浅出NodeJS/index.html">
<meta property="og:site_name" content="(<ゝω·)Kira☆~">
<meta property="og:description" content="模块机制CommonJS 规范模块引用var math = require(&apos;math&apos;);
CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文">
<meta property="og:image" content="http://yoursite.com/images/59-3-13.png">
<meta property="og:image" content="http://yoursite.com/images/61-3-14.png">
<meta property="og:updated_time" content="2015-08-24T12:55:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入浅出NodeJS">
<meta name="twitter:description" content="模块机制CommonJS 规范模块引用var math = require(&apos;math&apos;);
CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文">
  
    <link rel="alternative" href="/atom.xml" title="(&lt;ゝω·)Kira☆~" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">liyh</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">笔记</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cupools" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Javascript/" style="font-size: 16.67px;">Javascript</a> <a href="/tags/css/" style="font-size: 13.33px;">css</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/读书笔记/" style="font-size: 20px;">读书笔记</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">在校学生，连滚带爬啃书</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">liyh</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/avatar.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">liyh</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">笔记</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cupools" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-books/深入浅出NodeJS" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/07/books/深入浅出NodeJS/" class="article-date">
  	<time datetime="2015-08-06T16:00:00.000Z" itemprop="datePublished">2015-08-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入浅出NodeJS
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="模块机制">模块机制</h2><h3 id="CommonJS_规范">CommonJS 规范</h3><h4 id="模块引用">模块引用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure>
<p>CommonJS 规范中存在 require() 方法，接受模块标识，以此引入一个模块的 API 到当前的上下文</p>
<a id="more"></a>
<h4 id="模块定义">模块定义</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">arguments</span>[i]) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模块中，上下文提供 require() 方法引入外部模块，提供 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。模块存在一个 module 对象，代表模块本身，而 exports 对象是 module 的属性。在 Node 中，一个文件就是一个模块</p>
<h3 id="Node_的模块实现">Node 的模块实现</h3><p>Node 中引入模块经历的步骤如下：路径分析 =&gt; 文件定位 =&gt; 编译执行。其中，核心模块部分在 Node 源代码编译过程中，编译进了二进制执行文件，在 Node 进程启动时直接加载进内存中，只需要路径分析，并且在路径分析中优先判断</p>
<ul>
<li>优先从缓存加载</li>
<li>核心模块、路径形式的文件模块、自定义模块  <ul>
<li>Node 提供的模块属于核心模块</li>
<li>用户编写的模块属于文件模块。以<code>.</code>、<code>..</code>、<code>/</code>开始的标识符，被当做文件模块处理</li>
<li>自定义模块指的是非核心模块，也不是路径形式的标识符。可能是一个文件或者包的形式。沿路径向上逐级递归，直到根目录下的 node_module 目录为止，查找最费时</li>
</ul>
</li>
<li>文件定位，按 .js、.json、.node 的次序补足扩展名，依次尝试</li>
<li>目录分析和包，Node 在自定义模块目录下查找 package.json，通过<code>JSON.parse</code>解析，并取出 main 属性制定的文件名进行定位。如果没有 package.json，将依次查找 index.js、index.json、index.node</li>
<li>模块编译 TODO</li>
</ul>
<h3 id="包与NPM">包与NPM</h3><p>NPM 是 CommonJS 包规范理论的实践。符合 CommonJS 规范的包目录包含如下文件：</p>
<ul>
<li>package.json：包描述文件</li>
<li>bin：用于存放可执行二进制文件的目录</li>
<li>lib：用于存放 Javascript 代码的目录</li>
<li>doc：用于存放文档的目录</li>
<li>test：用于存放单元测试用例的代码</li>
</ul>
<h4 id="安装依赖包">安装依赖包</h4><ul>
<li><p>全局模式安装，是将一个包安装为全局可用的可执行命令。它根据包描述文件中的 bin 字段配置，将实际脚本链接到 Node 可执行文件相同的可执行路径下</p>
<p>  全局安装的模块包都背安装进一个统一的目录下，通过如下方式推算出来</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.resolve(process.execPath, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'lib'</span>, <span class="string">'node_module'</span>);</span><br></pre></td></tr></table></figure>
<p>  即 Node 可执行文件的位置是<code>/usr/local/bin/node</code>，则模块目录为 <code>/usr/local/lib/node_module</code></p>
</li>
<li><p>本地安装，只需要为 NPM 指明 package.json 文件所在位置即可，可以是一个包含 package.json 的存档文件，也可以是一个 URL 地址，也可以是一个目录下 package.json 文件的目录位置</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install &lt;tarball file&gt;</span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从非官方源安装</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install undescore --registry=http://registry.url</span><br></pre></td></tr></table></figure>
<p>  使用过程都使用镜像源安装</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry http://registry.url</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="异步I/O">异步I/O</h2><h3 id="Node_的异步I/O">Node 的异步I/O</h3><h4 id="事件循环">事件循环</h4><p>Node 进程启动时，会启动一个循环，每执行一次循环称为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程</p>
<p>事件循环是一个典型的生产者 / 消费者模型。异步 I/O、网络请求等则是事件的生产者，为 Node 提供不同类型的事件，这些事件被传递到对应的观察者，事件循环则从观察者那里取出事件并做处理</p>
<h4 id="请求对象">请求对象</h4><p>从 Javascript 调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，这是 Node 里经典的调用方式。这里 libuv 作为封装层，有两个平台的实现。调用过程中会创建一个请求对象并推入线程池中等待执行。不管当前的 I/O 操作是否阻塞 I/O，都不会影响到 Javascript 线程的后续执行</p>
<h4 id="执行回调">执行回调</h4><p>组装好请求对象、送入 I/O 线程池等待执行，实际上完成了异步 I/O 的第一部分，回调通知是第二部分。在线程池中的 I/O 操作调用完毕之后，会储存获取的结果然后通知 IOCP，告知当前对象操作已经完成</p>
<p><img src="/images/59-3-13.png" alt="异步 I/O 流程"></p>
<p>事件循环、观察者、请求对象、I/O 线程池这四者共同构成了 Node 异步 I/O 模型的基本要素</p>
<p>Windows 下主要通过 IOCP 来向系统内核发送 I/O 调用和从内核获取已完成的 I/O 操作，配以事件循环，以此完成异步 I/O 的过程。在 Linux 下通过 epoll 实现这个过程，FreeBSD 下通过 kqueue 实现，Solaris 下通过 Event ports 实现。不同的是线程池在 Windows 下由内核（IOCP）直接提供，*nix 系列下由 libuv 自行实现</p>
<h4 id="小结">小结</h4><p>在 Node 中，除了 Javascript 是单线程歪，Node 自身是多线程，只是 I/O 线程使用的 CPU 较少。另一个观点是，除了用户代码无法并行执行外，所有的 I/O 则是并行起来的</p>
<h3 id="非_I/O_的异步_API">非 I/O 的异步 API</h3><h4 id="定时器">定时器</h4><p>setTimeout() 和 setInterval() 与浏览器中的 API 是一致的。它们的实现原理与异步 I/O 类似，只是不需要 I/O 线程池的参与。创建的计时器会被插入到定时器观察者内部的一个红黑树中，每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将会立即执行</p>
<p>定时器的问题并不精确，例如通过计时器设定一个任务在10毫秒后执行，但在9毫秒后，有一个任务占用了5毫秒的 CPU 时间片，再次轮到定时器执行时，时间就已经过期4毫秒了</p>
<p><img src="/images/61-3-14.png" alt="setTimeout() 的行为"></p>
<h4 id="process-nextTick()">process.nextTick()</h4><p>采用定时器需要动用红黑树，创建定时器对象和迭代等操作。相比执行，process.nextTick() 方法的操作相对较为轻量</p>
<p>每次调用 process.nextTick() 方法，只会将回调函数放入队列中，在下一轮 Tick 时取出执行。定时器中采用红黑树的操作时间复杂度为 O(lg(n))，nextTick() 的时间复杂度为 O(1)</p>
<h4 id="setImmediate()">setImmediate()</h4><p>process.nextTick() 中的回调函数执行的优先级高于 setImmediate()，原因在于事件循环对观察者的检查有先后顺序。process.nextTick() 属于 idle 观察者，setImmediate() 属于 check 观察者。在每一轮循环检查中，idle 观察者优先于 I/O 观察者，I/O 观察者优先于 check 观察者</p>
<h3 id="事件驱动与高性能服务器">事件驱动与高性能服务器</h3><p>几种经典的服务器模型</p>
<ul>
<li>同步式。对于同步式的服务，一次只能主力一个请求，并且其余请求都处于等待状态</li>
<li>每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多</li>
<li>每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程轻量，但是每个线程都占用一定内存，大并发请求来时，内存会很快耗光</li>
</ul>
<p>Node 通过事件驱动的方式处理请求，无需为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销</p>
<h2 id="异步编程">异步编程</h2><h3 id="异步编程难点">异步编程难点</h3><ul>
<li>异常处理</li>
<li>函数嵌套过深</li>
<li>阻塞代码</li>
<li>多线程编程</li>
<li>异步转同步</li>
</ul>
<h3 id="异步解决方案">异步解决方案</h3><ul>
<li>事件发布 / 订阅模式</li>
<li>Promise / Deferred 模式</li>
<li>流程控制库</li>
</ul>
<h4 id="时间发布/订阅模式">时间发布/订阅模式</h4><p>订阅事件是一个高阶函数的应用。事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。从另一个角度看，事件侦听器模式也是一种钩子机制，利用钩子导出内部数据或状态给外部的调用者</p>
<p>Node 对事件发布/订阅的机制做了一些额外的处理</p>
<ul>
<li>如果对一个事件添加超过 10 个侦听器，将会得到一条警告。可以调用 <code>emmiter.setMaxListeners(0)</code>去除限制</li>
<li>EventEmmiter 对象对 error 事件进行了特殊对待。如果运行期间的错误触发了 error 事件，EventEmitter 会检查是否由对 error 事件添加过侦听器。如果有，则将错误交给该侦听器处理，否则作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出</li>
</ul>
<p>通过继承 events 模块可实现事件机制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Stream, events.EventEmitter);</span><br></pre></td></tr></table></figure>
<h4 id="多异步之间的协作方案">多异步之间的协作方案</h4><p>由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间相互没有任何交集，因此需要借助一个第三方函数和第三方变量来处理异步写作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>, results = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        results[key] = value;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count === times) &#123;</span><br><span class="line">            callback(results);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.Emitter();</span><br><span class="line">vr done = after(times, render);</span><br><span class="line"></span><br><span class="line">emitter.on(<span class="string">'done'</span>, done);</span><br><span class="line"></span><br><span class="line">fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    emitter.emit(<span class="string">'done'</span>, <span class="string">'template'</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    emitter.emit(<span class="string">'done'</span>, <span class="string">'data'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span>(<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">    emitter.emit(<span class="string">'done'</span>, <span class="string">'resources'</span>, resources);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 EventProxy 解决异步协作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> EventProxy();</span><br><span class="line">proxy.all(<span class="string">'template'</span>, <span class="string">'data'</span>, <span class="string">'resources'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">template, data, resources</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(path, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">'template'</span>, template);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">'data'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span>(<span class="params">resources</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">'resources'</span>, resources)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise_/_Deferred_模式">Promise / Deferred 模式</h3><h4 id="Promise/A">Promise/A</h4><p>Promise/A 对单个异步操作的抽象定义如下</p>
<ul>
<li>Promise 只会出于三种状态中的一种：未完成态、完成态或失败态</li>
<li>Promise 的状态只会出现从未完成态向完成态或失败态转化，不能你装。完成态和失败态不能相互转化</li>
<li>Promise 的状态一旦转化，将不能被改变</li>
</ul>
<p>Promise/A 提议在 API 的定义中，一个 Promise 对象只要具备 then() 方法即可，有如下要求</p>
<ul>
<li>接受完成态、错误态的回调函数。在操作完成或者出现错误时，将会调用对应方法</li>
<li>可选地支持 progress 事件回调作为第三个方法</li>
<li>then() 方法只接受 function dioxide。其余对象将被忽略</li>
<li>then() 方法继续放回 Promise 对象，以实现链式调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(fulfilledHandler, errorHandler, progressHandler)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">util.inherits(<span class="built_in">Promise</span>, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">fulfilledHandler, errorHandler, progressHandler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.once(<span class="string">'success'</span>, fulfilledHandler);</span><br><span class="line">    <span class="keyword">this</span>.once(<span class="string">'error'</span>, errorHandler);</span><br><span class="line">    <span class="keyword">this</span>.on(<span class="string">'progress'</span>, progressHandler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>then() 方法将回调函数存放起来。为了完成整个流程，还需要执行这些回调函数的地方，实现这些功能的对象称为 Deferred，即延迟对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'unfulfilled'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'success'</span>, obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'failed'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'error'</span>, err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.progress = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'progress'</span>, data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>封装业务代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promisify = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">    </span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        result += chunk;</span><br><span class="line">        deferred.progress(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferred.resolve(result);</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        deferred.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型响应对象的调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promisify(res).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Error</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// progress</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'BODY: '</span> + chunk);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>与事件发布/订阅模式相比，Promise/Deferred 模式的 API 接口和抽象模型都十分简洁。它将业务中不可变的部分封装在了 Deferred 中，将可变的部分交给了 Promise。对于不同场景需要封装对应的 Deferred 部分</p>
<p>多异步协作可通过哨兵变量和 result 数组实现</p>
<h4 id="流程控制库">流程控制库</h4><ul>
<li><p>尾触发与 Next<br>需要手工调用才能持续执行后续调用的方法属于尾触发，常见的关键词是 next。目前应用最多的diff是 Connect 的中间件，在处理网络请求时，可以像面向切面编程一样进行过滤，验证，日志等功能，而不与具体业务逻辑产生关联，以致产生耦合</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = connect();</span><br><span class="line">app.use(connect.staticCache());</span><br><span class="line">app.use(connect.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.use(connect.query());</span><br><span class="line">app.use(connect.bodyParse());</span><br><span class="line">aoo.listen(<span class="number">3001</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//中间件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>async</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// result =&gt; [file1.txt, file2.txt]s</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Step</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 串行依次执行</span></span><br><span class="line">Step(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readFile1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readFile2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">donw</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(content);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>wind</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Wind = <span class="built_in">require</span>(<span class="string">'wind'</span>);</span><br><span class="line"><span class="keyword">var</span> Task = Wind.Async.Task;</span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">file, encoding</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.create(<span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">        fs.readFile(file, encoding, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.err) &#123;</span><br><span class="line">                t.complete(<span class="string">'failure'</span>, err);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t.complete(<span class="string">'success'</span>, file)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> series = <span class="built_in">eval</span>(Wind.compile(<span class="string">'async'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> file1 = $<span class="keyword">await</span>(readFileAsync(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(file1);</span><br><span class="line">    <span class="keyword">var</span> file2 = $<span class="keyword">await</span>(readFileAsync(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(file2);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> file1 = $<span class="keyword">await</span>(readFileAsync(<span class="string">'file3.txt'</span>, <span class="string">'utf-8'</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="异步并发控制">异步并发控制</h4><ul>
<li><p>bagapipe 的解决方案</p>
<ul>
<li>通过一个队列来控制并发量</li>
<li>如果当前活跃的异步调用量小于限量值，从队列中取出执行</li>
<li>如果活跃调用达到限量值，调用暂时存放在队列中</li>
<li><p>每个异步调用结束时，从队列中取出新的异步调用执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Bagpipe = <span class="built_in">require</span>(<span class="string">'bagpipe'</span>);</span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">    bagpipe.push(<span class="keyword">async</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 异步回调执行</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">bagpipe.on(<span class="string">'full'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'full queue: '</span> + length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>async</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallelLimit([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">], <span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> q = <span class="keyword">async</span>.queue(<span class="function"><span class="keyword">function</span>(<span class="params">file, callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(file, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">&#125;, <span class="number">2</span>);</span><br><span class="line">q.drain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// done</span></span><br><span class="line">&#125;;</span><br><span class="line">fs.readdirSync(<span class="string">'.'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    q.push(file, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="内存控制">内存控制</h2><h3 id="V8的垃圾回收机制与内存限制">V8的垃圾回收机制与内存限制</h3><p>在 V8 中，所有的 Javascript 对象都是用过堆来进行分配的。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制。V8 限制堆的大小，原因在于垃圾回收中会引起 Javascript 线程暂停执行，而糟糕情况下造成的时间花销将影响应用性能和响应能力</p>
<p>V8 中，将内存分为新生代和老生代。新生代中得对象为存活时间较短的对象，老生代中的对象为存活时间较长或者常驻内存的对象</p>
<p>分代的基础上，新生代中的对象主要通过 Scavenge 算法进行垃圾回收。在 Scavenge 的具体实现中，主要采用了 Cheney 算法。简单表述，在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间中进行复制，属于典型的牺牲空间换取时间的算法</p>
<p>在一定条件下，需将存活周期长的对象移动到老生代中，也就是完成对象晋升。判断条件为对象是否经历过 Scavenge 回收和 To 空间的内存占用比超过限制</p>
<p>老生代空间中得对象接受新的回收算法处理，主要采用 Mark-Sweep 和 Mark-Compact 相结合的方式。Mark-Sweep 是标记清楚的意思，分为标记和清理清除两个阶段；Mark-Compact 解决 Mark-Sweep 的内存碎片问题，将存活的对象往一端移动，完成后直接清理掉边界外的内存</p>
<p>为了避免出现 Javascript 应用逻辑与垃圾回收期看到不一致的情况，垃圾回收的3种基本算法都需将应用逻辑暂停下来，待执行完垃圾回收之后在回复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。全堆垃圾回收的标记、清理、整理等动作造成的停顿比较可怕，因此采用增量标记（incremental marking），垃圾回收与应用逻辑交替执行直到标记阶段完成</p>
<h3 id="高效使用内存">高效使用内存</h3><h4 id="作用域">作用域</h4><p>在 Javascript 中能形成作用域的有函数调用、with 和全局作用域。作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁</p>
<p>如果变量是全局变量（不通过 var 声明或定义在 global 上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过 delete 操作来删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系，在接下来的老生代内存清除和整理的过程中，会被回收释放</p>
<h4 id="闭包">闭包</h4><p>实现外部作用域访问内部作用域中的变量的方法叫做闭包。一旦有变量引用内部作用域的变量，原始的作用域不会得到释放</p>
<h3 id="内存指标">内存指标</h3><h4 id="查看进程的内存占用">查看进程的内存占用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">process.memoryUsage()</span><br><span class="line"><span class="comment">// =&gt; &#123;rss: 13852672, heapTotal: 6131200, heapUsed: 2757120&#125;</span></span><br></pre></td></tr></table></figure>
<p>rss 是 resident set size 的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区（swap）或者文件系统（filesystem）中</p>
<p>除了 rss 歪，heapTotal 和 heapUsed 对应的是 V8 的堆内存信息，heapTotal 是堆中总共申请的内存量，heapUsed 表示目前堆中使用中的内存量。三个值的单位都是字节</p>
<h4 id="查看系统内存占用">查看系统内存占用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">os.totalmem()</span><br><span class="line"><span class="comment">// =&gt; 8589934592</span></span><br><span class="line">os.freemem()</span><br><span class="line"><span class="comment">// =&gt; 1025601536</span></span><br></pre></td></tr></table></figure>
<h4 id="堆外内存">堆外内存</h4><p>process.memoryUsage() 的结果可知，堆中的内存用量总是小于进程的常驻内存用量，意味着 Node 中的内存使用并非都是通过 V8 进行分配的，我们将那些不是通过 V8 分配的内存称为堆外内存</p>
<p>Buffer 对象不同于其他对象，它不经过 V8 的内存分配机制，所以不会有堆内存的大小限制</p>
<h4 id="小结-1">小结</h4><p>Node 的内存构成主要是通过 V8 进行分配的部分和 Node 自行分配的部分，受 V8 的垃圾回收限制的主要是 V8 的堆内存</p>
<h3 id="内存泄露">内存泄露</h3><p>实质是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。可能的原因有：缓存、队列消费不及时、作用域未释放</p>
<h4 id="缓存限制机制">缓存限制机制</h4><p>由于模块的缓存机制，模块都是常驻老生代的。在设计模块时，要十分小心内存泄露的出现，避免调用导出方法时不停增加内存的占用。当不可避免时可添加相关接口供使用者释放内存</p>
<h4 id="缓存的解法方案">缓存的解法方案</h4><p>大量使用缓存的一个解决方法是使用进程外的缓存，进程自身不储存状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能，在 Node 中可解决以下问题</p>
<ul>
<li>将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更加高效</li>
<li>进程之间可以共享缓存</li>
</ul>
<h4 id="关注队列状态">关注队列状态</h4><p>队列在消费者-生产者模式中经常充当中间产物，当消费速度低于生成速度，将会形成堆积，出现内存泄露。表面的解决方案是换用消费速度更高的技术；深度的解决方案是监控队列的长度，一旦堆积，应通过监控系统产生报警通知相关人员，或者为任意异步调用添加超时机制</p>
<h3 id="内存泄露排查">内存泄露排查</h3><p>定位 Node 应用的内存泄露的常用工具如下：</p>
<ul>
<li>v8-profiler</li>
<li>node-heapdump</li>
<li>dtrace</li>
<li>node-memwatch</li>
</ul>
<h2 id="理解_Buffer">理解 Buffer</h2><h3 id="Buffer_结构">Buffer 结构</h3><h4 id="模块结构">模块结构</h4><p>Buffer 是一个典型的 Javascript 与 C++ 结合的模块，它将性能相关部分用 C++ 实现，将非性能相关的部分用 Javascript 实现</p>
<h4 id="Buffer_对象">Buffer 对象</h4><p>Buffer 对象类似数组，它的元素为16进制的两位数，即0到255的数值。其中中文字符在 UTF-8 编码下占用3个元素，字母和半角标点符号占用一个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'深入浅出node.js'</span>;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(str, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"><span class="comment">// =&gt; &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span></span><br></pre></td></tr></table></figure>
<p>给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于256，就逐次减256。如果是小数，舍弃小数部分，只保留整数部分</p>
<h4 id="Buffer_内存分配">Buffer 内存分配</h4><p>Node 使用 slab 分配机制使用申请来的内存。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和事后分配，使得 Javscript 到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的 Buffer 而言，则直接使用 C++ 层面提供的内存，而无需细腻的分配操作</p>
<h3 id="Buffer_的转换">Buffer 的转换</h3><p>Buffer 对象与字符串之间相互转换，目前支持的字符串编码类型如下：</p>
<ul>
<li>ASCII</li>
<li>UTF-8</li>
<li>UTF-16LE/UCS-2</li>
<li>Base64</li>
<li>Binary</li>
<li>Hex</li>
</ul>
<h4 id="字符串转_Buffer">字符串转 Buffer</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</span><br><span class="line">buf.write(string, [offset], [length], [encoding]);</span><br></pre></td></tr></table></figure>
<p>通过构造函数转换的 Buffer 对象，存储的只能是一种编码类型，encoding 参数不传递时，默认按 UTF-8 编码进行转码和存储。调用 write() 方法可以在一个 Buffer 对象中存储不同编码类型的字符串编码的至，但需要小心每种编码所用的字节长度不同，将 Buffer 对象反转成字符串时需谨慎处理</p>
<h4 id="Buffer_转字符串">Buffer 转字符串</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end]);</span><br></pre></td></tr></table></figure>
<h4 id="buffer_不支持的编码类型">buffer 不支持的编码类型</h4><p>Buffer 对象提供 isEncoding() 函数判断编码是否支持转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Buffer.isEncoding(encoding);</span><br></pre></td></tr></table></figure>
<p>可借助 iconv-lite 或 iconv 支持更多编码类型。前者采用纯 Javascript 实现，更轻量，无需编译和处理环境依赖直接使用；后者通过 C++ 调用 libiconv 库实现。性能方面由于转码都是耗用 CPU，在 V8 下少了 C++ 到 Javascript 层次的转换，纯 Javascript 的性能比 C++ 实现更好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iconv = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = iconv.decode(buf, <span class="string">'win1251'</span>);</span><br><span class="line"><span class="keyword">var</span> buf = iconv.encode(str, <span class="string">'win1251'</span>);</span><br></pre></td></tr></table></figure>
<p>iconv-lite 和 iconv 对无法转换的内容进行降级处理时的方案不同</p>
<h3 id="Buffer_的拼接">Buffer 的拼接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'rs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>data 事件中获取的 chunk 对象即是 Buffer 对象。因此，拼接 data 的过程中，相当于隐藏调用了<code>chunk.toString()</code>（默认以UTF-8编码）。如果存在宽字节编码，则可能出现乱码</p>
<p>可以通过为可读流设置编码，使 data 事件中传递的不再是一个 Buffer 对象，而是编码后的字符串.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line">fs.setEncoding(<span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure>
<p>事实上，调用 setEncoding() 时，可读流对象在内部设置了一个 decoder 对象。每次都通过该 decoder 对象进行 Buffer 到字符串的解码，然后传递给调用者。decoder 对象来自于 string_decoder 模块 StringDecoder 的实例对象，能根据编码类型处理可读流的字节长度问题。但它目前只能处理 UTF-8、 Base64 和 UCS-2/UTF-16LE 这三种编码</p>
<p>可通过 iconv-lite 一类的模块，将可读流获取的 Buffer 对象拼接后做转换，解决转码问题</p>
<h3 id="Buffer_与性能">Buffer 与性能</h3><p>字符串一旦在网络中传输，都需要转换为 Buffer，以进行二进制数据传输。通过预先转换静态内容为 Buffer 对象，可以有效地减少 CPU 的重复使用，节省服务器资源</p>
<p>Buffer 的使用除了与字符串的转换有性能耗损外，在文件读取时，还有一个 highWaterMark 设置对性能的影响至关重要。lighWaterMark 限制每次读取的长度，对 Buffer 内存的分配和使用有一定影响，设置过小可能导致系统调用次数过多。</p>
<p>文件流读取基于 Buffer 分配，Buffer 则基于 SlowBuffer 分配</p>
<h2 id="网络编程">网络编程</h2><p>Node 提供了 net、 dgram、 http、 https 这4个模块，分别用于处理 TCP、 UDP、 HTTP、 HTTPS</p>
<h3 id="构建_TCP_服务">构建 TCP 服务</h3><p>TCP 全名为传输控制协议，在 OSI 模型（由七层组成，分别为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于 TCP 构建，典型的是 HTTP、 SMTP、 IMAP 等协议</p>
<p>TCP 是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端和客户端则通过套接字实现两者之间连接的操作</p>
<h4 id="服务器事件">服务器事件</h4><ul>
<li><p>listening：在调用 server.listen() 绑定端口或者 Domain Socket 后触发，简洁写法为</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.listen(port, listeneringListener)</span><br></pre></td></tr></table></figure>
</li>
<li><p>connection：每个客户端套接字连接到服务器端时触发，简介写法为通过 net.createServer()，最后一个参数传递</p>
</li>
<li>close：当服务器关闭时触发，在调用 server.close() 后，服务器将停止接受新的套接字连接，但保存当前存在的连接，等待所有连接都断开后，会触发该事件</li>
<li>error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常。如果不侦听 error 事件，服务器将会抛出异常</li>
</ul>
<h4 id="连接事件">连接事件</h4><p>服务器可以通过与多个客户端保持连接，对于每个连接而言是典型的可写可读 Stream 对象。Stream 可用户与服务器和客户端之间的通信，它具有如下自定义事件</p>
<ul>
<li>data：当一段调用 write() 发送数据时，另一端会触发 data 事件</li>
<li>end：当连接中的任意一端发送了 FIN 数据时，触发该事件</li>
<li>connect：用于客户端，当套接字与服务器端连接成功时被触发</li>
<li>drain：当任意一端调用 write() 发送数据时，当前这端会触发该事件</li>
<li>error：异常发生时候触发</li>
<li>close：当套接字完全关闭时触发</li>
<li>timeout：当一定时间后连接不再活跃时触发，通知用户当前该连接已经被闲置</li>
</ul>
<p>TCP 针对网络中的小数据包有一定的优化策略：Nagle 算法。要求缓冲区的文件达到一定数量或者一定时间后才将其发出，所以数据包会被 Nagle 算法合并，以此优化网络，但数据可能被延迟发送。Node 中 TCP 默认使用 Nagle 算法，可以使用<code>socket.setNoDelay(true)</code>取消。尽管如此，并不意味着每次 write() 都会触发一次 data 事件，另一端可能将会接收到多个小数据包合并，然后只触发一次 data 事件</p>
<h3 id="构建_UDP_服务">构建 UDP 服务</h3><p>UDP 又称用户数据包协议，与 TCP 一样属于网络传输层。与 TCP 最大不同是 UDP 不是面向连接的。TCP 中连接一旦简历，所有的绘画都会基于连接完成，客户端如果要与另一个 TCP 服务通信，需要另外创建一个套接字来完成连接。但在 UDP 中，一个套接字可以与多个 UDP 服务通信，它提供面向事务的简单不可靠信息传输服务，在网络差的情况下丢包严重，但由于它无需连接，资源消耗低，处理快速且灵活，所以常用于偶尔丢包也不会产生重大影响的场景，如音频、视频等。DNS 服务是基于 UDP 实现的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">var</span> server = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg, rinfo</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server got: '</span> + msg + <span class="string">'from '</span> + rinfo.address);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> address = server.address();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server listening '</span> + address.address);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 该套接字将接受所有网卡上41234端口上的消息</span></span><br><span class="line"><span class="comment">// 绑定完成后将触发 listening 事件</span></span><br><span class="line">server.bind(<span class="number">41234</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> Buffer(<span class="string">'msg from client'</span>);</span><br><span class="line"><span class="keyword">var</span> client = dgram.createSocket(<span class="string">'udp4'</span>);</span><br><span class="line">client.send(message, <span class="number">0</span>, message.length, <span class="number">41234</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>) </span>&#123;</span><br><span class="line">    client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="UDP_套接字事件">UDP 套接字事件</h4><p>UDP 套接字只是一个 EventEmitter 的实例，而非 Stream 的实例</p>
<ul>
<li>message：当 UDP 套接字侦听网卡端口后，接受到消息时触发该事件，触发携带的数据为消息 Buffer 对象和一个远程地址信息</li>
<li>listening：当 UDP 套接字开始侦听时触发事件</li>
<li>close：调用 close() 方法时触发该事件，并不再触发 message 事件</li>
<li>error：当异常发生时触发该事件，如果不侦听，异常将直接抛出</li>
</ul>
<h3 id="构建_HTTP_服务">构建 HTTP 服务</h3><p>TCP 和 UDP 都属于网络传输层协议，如果要构造高效的网络应用，应该从传输层进行着手。HTTP 构建与 TCP 之上</p>
<h4 id="HTTP_报文">HTTP 报文</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -v http://baidu.com</span><br><span class="line">* Rebuilt URL to: http://baidu.com/</span><br><span class="line">*   Trying <span class="number">180.149</span>.<span class="number">132.47</span>...</span><br><span class="line">* Connected to baidu.com (<span class="number">180.149</span>.<span class="number">132.47</span>) port <span class="number">80</span> (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.43</span>.<span class="number">0</span></span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">&lt; Date: Sat, <span class="number">22</span> Aug <span class="number">2015</span> <span class="number">14</span>:<span class="number">07</span>:<span class="number">42</span> GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Cache-Control: max-age=<span class="number">86400</span></span><br><span class="line">&lt; Expires: Sun, <span class="number">23</span> Aug <span class="number">2015</span> <span class="number">14</span>:<span class="number">07</span>:<span class="number">42</span> GMT</span><br><span class="line">&lt; Last-Modified: Tue, <span class="number">12</span> Jan <span class="number">2010</span> <span class="number">13</span>:<span class="number">48</span>:<span class="number">00</span> GMT</span><br><span class="line">&lt; ETag: <span class="string">"51-4b4c7d90"</span></span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: <span class="number">81</span></span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection <span class="comment">#0 to host baidu.com left intact</span></span><br></pre></td></tr></table></figure>
<p>第一部分是 TCP 的3次握手的过程；第二部分是完成握手之后，客户端向服务器端发送请求报文；第三部分是服务器端完成处理后，向客户端发送响应内容，包括响应头和响应体；最后是结束会话的信息</p>
<p>HTTP 是基于请求响应式的，虽然基于 TCP 会话，但本身却并无会话的特点</p>
<h4 id="http_模块">http 模块</h4><p>HTTP 服务与 TCP 服务模型由区别的地方在于，在开启 keepalive 后，一个 TCP 服务可以用于多次请求和响应。TCP 服务以 connection 为单位进行服务，HTTP 服务以 request 为单位进行服务。http 模块即是将 connection 到 request 的过程进行了封装</p>
<p>除此之外，http 模块将连接所用套接字的读写抽象为 ServerRequest 和 ServerResponse 对象，分别对应请求和响应操作</p>
<h4 id="HTTP_请求">HTTP 请求</h4><p>对于 TCP 连接的读操作，http 模块将其封装为 ServerRequest 对象。报文头被解析防止在 req.headers 属性上，报文体部分则抽象为一个只读流对象</p>
<h4 id="HTTP_响应">HTTP 响应</h4><p>封装了对底层连接的写操作，可以将其看做一个可写的流对象。报文头信息通过<code>setHeader()</code>和<code>writeHead()</code>写入，报文体通过调用<code>res.write()</code>和<code>res.end()</code>方法实现。无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用<code>res.end()</code>结束请求，否则客户端将会一直处于等待状态。也可以通过延迟 res.end() 的方法实现客户端与服务器端的长连接，但结束时务必关闭连接</p>
<h4 id="HTTP_服务的事件">HTTP 服务的事件</h4><ul>
<li>connection 事件：在开始 HTTP 请求和响应之前，客户端与服务器端需要建立底层的 TCP 连接，这个连接可能因为开启了 keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次 connection 事件</li>
<li>request 事件：建立 TCP 连接后，http 模块底层将在数据流中抽象出 HTTP 请求和 HTTP 响应，当请求数据发送到服务器端，在解析出 HTTP 请求头后，将会触发该事件；在 res.end() 之后，TCP 连接可能将用于下一次响应请求</li>
<li>close 事件：与 TCP 服务器的行为一致，调用 server.close() 方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给 server.close() 传递一个回调函数来快速注册该事件</li>
<li>checkContinue 事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带<code>Except: 100-continue</code>的请求到服务器，服务器触发该事件；如果没有为服务器监听该事件，服务器将会自动响应客户端<code>100 Continue</code>的状态码，表示接受数据上传；否则响应<code>400 Bad Request</code>拒绝客户端发送数据。需要注意的是，该事件不会触发 request 事件，两个事件互斥。当客户端收到<code>100 Continue</code>后重新发起请求时，才会触发 request 事件</li>
</ul>
<h4 id="HTTP_客户端">HTTP 客户端</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    hostname: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="string">'1334'</span>,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    method: <span class="string">'GET'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// res.statusCode;</span></span><br><span class="line">    <span class="comment">// res.headers;</span></span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>options 参数决定了 HTTP 请求头的内容</p>
<ul>
<li>host：服务器的域名或 IP 地址，默认为 localhost</li>
<li>hostname：服务器名称</li>
<li>port：服务器端口，默认为 80</li>
<li>localAddress：简历网络连接的本地网卡</li>
<li>socketPath：Domain 套接字路径</li>
<li>method：HTTP 请求方法，默认为 GET</li>
<li>path：请求路径，默认为 /</li>
<li>headers：请求头对象</li>
<li>auth：Basic 认证，这个值将被计算成请求头中的 Authorization 部分</li>
</ul>
<h4 id="HTTP_代理">HTTP 代理</h4><p>http 提供的 CLientRequest 对象也是基于 TCP 层实现，在 keepalive 的情况下，一个底层会话连接可以多次用于请求。为了重用 TCP 链接，http 模块包含一个默认的客户端代理对象 http.globalAgent。它对每个服务器端（host+port）创建的连接进行了管理，默认情况下，通过 CLientRequest 对象对同一个服务器发情的 HTTP 请求最多可以创建五个连接。它实质上是一个连接池</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/08/01/notes/正则表达式/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">正则表达式</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 liyh
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>