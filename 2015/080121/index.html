<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 基于MVC的Javascript Web富应用开发 - 一环的笔记</title><meta name="description" content="基于MVC的Javascript Web富应用开发 - liyh"><meta name="description" content="接到 HR 的面试通知，NodeJS 还没喵完便急匆匆地翻了这本书。等了好久还是没货打折只能跟别人借了
MVC和类什么是 MVCMVC 是一种设计模式，将应用划分为3个部分：数据（模型），展示层（视图），用户交互层（控制器）。一个事件发生的过程是这样的

用户和应用发生交互


控制器的事件处理器被触发
控制器从模型中请求数据，并将棋交给视图
视图将数据呈现给用户">
<meta property="og:type" content="article">
<meta property="og:title" content="基于MVC的Javascript Web富应用开发">
<meta property="og:url" content="http://cupools.github.io/2015/080121/index.html">
<meta property="og:site_name" content="一环的笔记">
<meta property="og:description" content="接到 HR 的面试通知，NodeJS 还没喵完便急匆匆地翻了这本书。等了好久还是没货打折只能跟别人借了
MVC和类什么是 MVCMVC 是一种设计模式，将应用划分为3个部分：数据（模型），展示层（视图），用户交互层（控制器）。一个事件发生的过程是这样的

用户和应用发生交互


控制器的事件处理器被触发
控制器从模型中请求数据，并将棋交给视图
视图将数据呈现给用户">
<meta property="og:updated_time" content="2016-08-26T14:12:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基于MVC的Javascript Web富应用开发">
<meta name="twitter:description" content="接到 HR 的面试通知，NodeJS 还没喵完便急匆匆地翻了这本书。等了好久还是没货打折只能跟别人借了
MVC和类什么是 MVCMVC 是一种设计模式，将应用划分为3个部分：数据（模型），展示层（视图），用户交互层（控制器）。一个事件发生的过程是这样的

用户和应用发生交互


控制器的事件处理器被触发
控制器从模型中请求数据，并将棋交给视图
视图将数据呈现给用户"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://cupools.github.io/atom.xml" title="一环的笔记"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/cupools" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="mailto:cupools@gmail.com" target="_self" class="nav-list-link">GMAIL</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">基于MVC的Javascript Web富应用开发</h1><div class="post-info">Aug 1, 2015<ul class="post-tag-list"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul></div><div class="post-content"><p>接到 HR 的面试通知，NodeJS 还没喵完便急匆匆地翻了这本书。等了好久还是没货打折只能跟别人借了</p>
<h2 id="MVC和类"><a href="#MVC和类" class="headerlink" title="MVC和类"></a>MVC和类</h2><h3 id="什么是-MVC"><a href="#什么是-MVC" class="headerlink" title="什么是 MVC"></a>什么是 MVC</h3><p>MVC 是一种设计模式，将应用划分为3个部分：数据（模型），展示层（视图），用户交互层（控制器）。一个事件发生的过程是这样的</p>
<ol>
<li>用户和应用发生交互</li>
</ol>
<ul>
<li>控制器的事件处理器被触发</li>
<li>控制器从模型中请求数据，并将棋交给视图</li>
<li>视图将数据呈现给用户</li>
</ul>
<a id="more"></a>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>模型用来存放应用的所有数据对象，不必知晓视图和控制器的细节，只需包含数据及直接和这些数据相关的模型。当控制器从服务器抓取数据或创建新的记录时，它就将数据包装成模型实例。即数据是面向对象的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 不推荐</span></div><div class="line"><span class="keyword">var</span> user = users[<span class="string">"foo"</span>];</div><div class="line">destoryUser(user);</div><div class="line"></div><div class="line"><span class="comment">// 推荐</span></div><div class="line"><span class="keyword">var</span> user = User.find(<span class="string">"foo"</span>);</div><div class="line">user.destory();</div></pre></td></tr></table></figure>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是呈现给用户的，用户与之产生交互</p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行处理，并相应地更视图</p>
<h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span>(<span class="params">parent</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> klass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(parent) &#123;</div><div class="line">        <span class="comment">// 通过匿名函数，避免创造 parent 实例</span></div><div class="line">        <span class="comment">// constructor 也被复制过去了</span></div><div class="line">        <span class="keyword">var</span> subClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">        subClass.prototype = parent.prototype;</div><div class="line">        klass.prototype = <span class="keyword">new</span> subClass();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    klass.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="keyword">return</span> klass;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Person = <span class="keyword">new</span> Class();</div><div class="line"></div><div class="line">Person.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 基于 Person 实例做初始化</span></div><div class="line">    <span class="comment">// 此处作为构造函数使用</span></div><div class="line">    <span class="comment">// 优点是所有类继承自 Class</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用法</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Class(Person);</div></pre></td></tr></table></figure>
<h3 id="控制类的作用域"><a href="#控制类的作用域" class="headerlink" title="控制类的作用域"></a>控制类的作用域</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 代理，方法属于调用对象，即 this/self 指向调用对象本身</span></div><div class="line">Obj.prototype.proxy = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        func.apply(self, <span class="built_in">arguments</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 绑定，方法属于函数本身，this/self 属于执行函数的当前上下文</span></div><div class="line"><span class="comment">// 不适用于改变上下文，这里可能造成误解</span></div><div class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</div><div class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> slice = [].slice,</div><div class="line">            args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),	<span class="comment">// 绑定时传入参数</span></div><div class="line">            self = <span class="keyword">this</span>,	<span class="comment">// 当前函数</span></div><div class="line">            nop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">            bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="comment">// 是否在当前上下文调用函数，是的话直接传入 this，否则传入 bind 时传入的上下文，并合并新传入的参数</span></div><div class="line">                <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> nop ? <span class="keyword">this</span> : (context || &#123;&#125;), args.concat(slice.call(<span class="built_in">arguments</span>)));</div><div class="line">            &#125;;</div><div class="line">        <span class="comment">// 匿名函数，避免实例化当前函数</span></div><div class="line">        nop.prototype = self.prototype;</div><div class="line">        <span class="comment">// bound 继承当前上下文的原型</span></div><div class="line">        bound.prototype = <span class="keyword">new</span> nop();</div><div class="line">        <span class="comment">// 返回绑定当前上下文的函数</span></div><div class="line">        <span class="keyword">return</span> bound;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="事件和监听"><a href="#事件和监听" class="headerlink" title="事件和监听"></a>事件和监听</h2><h3 id="取消事件"><a href="#取消事件" class="headerlink" title="取消事件"></a>取消事件</h3><p>浏览器给事件赋予了默认行为，如页面跳转、表单提交等。在事件传播阶段（之后）会触发这些默认行为，在任何一个事件处理程序中都可以调用 event 对象的 <code>preventDefault()</code> 阻止默认行为，同样也可以通过返回 <code>false</code> 实现</p>
<p>通过 <code>stopPropagation()</code> 阻止事件传播</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>bubbles</td>
<td>是否通过冒泡触发</td>
</tr>
<tr>
<td>button</td>
<td>鼠标按下的按钮</td>
</tr>
<tr>
<td>ctrlKey</td>
<td>Ctrl 键是否按下</td>
</tr>
<tr>
<td>altKey</td>
<td>Alt 键是否按下</td>
</tr>
<tr>
<td>shiftKey</td>
<td>Shift 键是否按下</td>
</tr>
<tr>
<td>metaKey</td>
<td>Meta 键是否按下</td>
</tr>
<tr>
<td>isChar</td>
<td>按下的键是否表示一个字符</td>
</tr>
<tr>
<td>charCode</td>
<td>当前按键的 unicode 值（针对 keypress 事件）</td>
</tr>
<tr>
<td>keyCode</td>
<td>表示非字符按键的 unicode 值</td>
</tr>
<tr>
<td>which</td>
<td>当前按键的 unicode 值，不管是否表示字符</td>
</tr>
<tr>
<td>currentTarget</td>
<td>事件冒泡阶段所在的当前 DOM 元素</td>
</tr>
<tr>
<td>target</td>
<td>原始的 DOM 元素</td>
</tr>
</tbody>
</table>
<h3 id="切换上下文"><a href="#切换上下文" class="headerlink" title="切换上下文"></a>切换上下文</h3><p>使用浏览器内置的 <code>addEventListener()</code> 时，上下文从局部变量切换为目标 HTML 元素。可通过事件代理保持当前的上下文</p>
<h3 id="委托事件"><a href="#委托事件" class="headerlink" title="委托事件"></a>委托事件</h3><p>事件绑定在父元素，jQuery 的 <code>selector.delegate()</code> 提供实现。所有为元素动态添加的子元素都具有事件监听</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>基于中介者模式，或者 jQuery 是实现的 <code>bind()</code> 和 <code>trigger()</code>，使代码整洁，具有扩展性。</p>
<h2 id="模型和数据"><a href="#模型和数据" class="headerlink" title="模型和数据"></a>模型和数据</h2><h3 id="MVC-和命名空间"><a href="#MVC-和命名空间" class="headerlink" title="MVC 和命名空间"></a>MVC 和命名空间</h3><p>将模型的属性保存至命名空间的做法可以确保不会发生冲突，同时符合 MVC 原则。并将真实 user 对象上得喝 user 实例相关的函数也添加进去。降入 user 记录包含一个 destroy() 函数，它是何具体的 user 相关的，则这个函数应当基于 User 实例调用</p>
<h3 id="构建对象关系映射（ORM）"><a href="#构建对象关系映射（ORM）" class="headerlink" title="构建对象关系映射（ORM）"></a>构建对象关系映射（ORM）</h3><p>ORM 是一个包装了一些数据的对象层。以往 ORM 常用于抽象 SQL 数据库，但这里 ORM 只是用于抽象 Javascript 数据类型。通过这个额外的层可以添加自定义的函数和属性来增强基础数据的功能</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">        F.prototype = o;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="通过-Ajax-载入数据"><a href="#通过-Ajax-载入数据" class="headerlink" title="通过 Ajax 载入数据"></a>通过 Ajax 载入数据</h3><p>Ajax 的一个限制是同源策略，它要求所有的请求必须来自同一个域名，子域名，并且地址的端口也应该一致。主要原因是出于安全考虑，因为当一个 Ajax 请示被发送，所有请求都会附带主域的 cookie 信息一起发送</p>
<p><strong>CORS</strong>（cross-origin resource sharing）允许跨域请求。只需要在 HTTP 协议的响应头添加：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line">Access-Control-Allow-Origin: emample.com</div><div class="line">Access-Control-Request-Method: GET, POST</div><div class="line"></div><div class="line">// 定义认证自定义的请求头</div><div class="line">Access-Control-Request-Headers: Authorization</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">req.open(<span class="string">'POST'</span>, <span class="string">'/example'</span>, <span class="literal">true</span>);</div><div class="line">req.setRequestHeader(<span class="string">'Authorization'</span>, oauth_signature)</div></pre></td></tr></table></figure>
<h3 id="本地储存数据"><a href="#本地储存数据" class="headerlink" title="本地储存数据"></a>本地储存数据</h3><p>HTML5 本地储存包含两类，<code>local storage</code> 和 <code>session storage</code>。浏览器端所储存的数据是以域名分隔开的，某个域中的脚本储存的数据只能被这个域读取。通常允许每个域名 5MB</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">localStorage[<span class="string">'someData'</span>] = <span class="string">'bmw'</span>;</div><div class="line"><span class="keyword">var</span> len = localStorage.length;</div><div class="line">localStorage.setItem(<span class="string">'someData'</span>) = <span class="string">'bmw'</span>;</div><div class="line">localStorage.getItem(<span class="string">'someData'</span>); <span class="comment">// =&gt; 'bmw'</span></div><div class="line">localStorage.removeItem(<span class="string">'someData'</span>);</div><div class="line">localStorage.clear();</div></pre></td></tr></table></figure>
<h2 id="控制器和状态"><a href="#控制器和状态" class="headerlink" title="控制器和状态"></a>控制器和状态</h2><p>控制器可以理解为应用中视图和模型之间的纽带。只有控制器知道视图和模型的存在并将他们连接在一起。当加载页面时，控制器将时间处理器程序绑定在视图里，并适时处理回调，以及和模型必要的对接</p>
</div></article></div></section><footer><div class="paginator"><a href="/2015/080118/" class="prev">PREV</a><a href="/2015/072817/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 <a href="http://cupools.github.io">liyh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-67000695-1",'auto');ga('send','pageview');</script></body></html>