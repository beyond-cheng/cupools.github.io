<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>编写高质量代码 | (&lt;ゝω·)Kira☆~</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在北京待了五天，没卫浴没网络没水没得正常吃饭，今天准备出去找房子打游击战。开始编写高质量代码。

语言基础
防止浮点数溢出，可转换为整数计算再转小数
调用 Object 对象定义的默认 toString 方法判断对象类型，Object.prototype.toString.apply( value ) ，仅适用于基本数据类型和内置对象。检测非内置对象使用 instanceof 和 construc">
<meta property="og:type" content="article">
<meta property="og:title" content="编写高质量代码">
<meta property="og:url" content="http://cupools.github.io/2015/07/cigq75fr3001d6xqcntg7wnls/index.html">
<meta property="og:site_name" content="(<ゝω·)Kira☆~">
<meta property="og:description" content="在北京待了五天，没卫浴没网络没水没得正常吃饭，今天准备出去找房子打游击战。开始编写高质量代码。

语言基础
防止浮点数溢出，可转换为整数计算再转小数
调用 Object 对象定义的默认 toString 方法判断对象类型，Object.prototype.toString.apply( value ) ，仅适用于基本数据类型和内置对象。检测非内置对象使用 instanceof 和 construc">
<meta property="og:updated_time" content="2015-10-28T08:54:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="编写高质量代码">
<meta name="twitter:description" content="在北京待了五天，没卫浴没网络没水没得正常吃饭，今天准备出去找房子打游击战。开始编写高质量代码。

语言基础
防止浮点数溢出，可转换为整数计算再转小数
调用 Object 对象定义的默认 toString 方法判断对象类型，Object.prototype.toString.apply( value ) ，仅适用于基本数据类型和内置对象。检测非内置对象使用 instanceof 和 construc">
  
    <link rel="alternative" href="/atom.xml" title="(&lt;ゝω·)Kira☆~" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<!-- <img lazy-src="/img/avatar.jpg" class="js-avatar"> -->
			<img src="/img/avatar.jpg" class="js-avatar show" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">liyh</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">笔记</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cupools" title="github">github</a>
					        
								<a class="mail" target="_blank" href="mailto:cupools@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Javascript/" style="font-size: 20px;">Javascript</a> <a href="/tags/Wordpress/" style="font-size: 10px;">Wordpress</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/学习/" style="font-size: 12.5px;">学习</a> <a href="/tags/安全/" style="font-size: 10px;">安全</a> <a href="/tags/碎屑/" style="font-size: 10px;">碎屑</a> <a href="/tags/读书笔记/" style="font-size: 17.5px;">读书笔记</a> <a href="/tags/配置/" style="font-size: 10px;">配置</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">在校学生，连滚带爬啃书</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">liyh</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/avatar.jpg" class="js-avatar show" style="width: 100%;height: 100%;opacity: 1;">
			</div>
			<hgroup>
			  <h1 class="header-author">liyh</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">笔记</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cupools" title="github">github</a>
			        
						<a class="mail" target="_blank" href="mailto:cupools@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-books/编写高质量代码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/cigq75fr3001d6xqcntg7wnls/" class="article-date">
  	<time datetime="2015-07-01T16:00:00.000Z" itemprop="datePublished">2015-07-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      编写高质量代码
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在北京待了五天，没卫浴没网络没水没得正常吃饭，今天准备出去找房子打游击战。开始编写<s>高质量</s>代码。</p>
</blockquote>
<h2 id="语言基础">语言基础</h2><ul>
<li>防止浮点数溢出，可转换为整数计算再转小数</li>
<li>调用 <code>Object</code> 对象定义的默认 <code>toString</code> 方法判断对象类型，<code>Object.prototype.toString.apply( value )</code> ，仅适用于基本数据类型和内置对象。检测非内置对象使用 <code>instanceof</code> 和 <code>constructor</code></li>
<li>NaN，使用 isFinite 和 typeof 检验数字类型</li>
<li>逗号运算符使用括号强迫进行连续运算，否则会出现先赋值再计算的问题</li>
<li><code>hasOwnProperty</code> 可被修改<s>（那解决方法咧）</s>（通过 iframe 获得原始对象）</li>
<li>伪数组不包含数组的方法</li>
<li><code>continue</code> 影响性能<s>（具体咧）</s>（<a href="http://jsperf.com/continuepsda" target="_blank" rel="external">jsperf</a> 测试发现几乎无差距）</li>
<li>关于 <code>new</code>，避免使用和给出的原因感觉很不合理</li>
</ul>
<a id="more"></a>
<h2 id="字符串、正则表达式和数组">字符串、正则表达式和数组</h2><ul>
<li>基于函数的迭代比基于循环的迭代占用时间多了八倍</li>
<li><code>replace</code> 的使用（<code>$&amp;, $`, $’, $123</code>）</li>
<li>数组长度不限，长度大于 2^32 或小于0时 <code>length</code> 不变，但可成功赋值和索引（IE9 和 chrome 测试）</li>
<li><code>arguments.callee</code> 可以调用当前匿名函数</li>
</ul>
<h2 id="函数式编程">函数式编程</h2><ul>
<li>使用 <code>Function</code> 构造函数创建的函数具有顶级作用域（运行时动态执行的缘故），function语句和函数直接量定义的函数都有自己的函数作用域（局部作用域）</li>
<li><code>arguments</code> 可通过apply调用数组的方法实现补丁</li>
<li>Javascript 的非惰性求值特征，函数参数无论是否使用都会被计算；惰性编程的角度要求消除不必要的计算</li>
<li>惰性实例化，闭包添加 <code>getInstance</code> 方法延迟实例化</li>
<li><p>惰性载入函数，在函数内部改变自身，使得函数执行的分支仅会发生一次（代码有内存泄漏的可能？)</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数绑定，创建一个闭包，并传入上下文</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// el.addEventListener('click', bind(fn, ctx), false)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数节流，简单的函数如下</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    clearTimeout(method.tid);</span><br><span class="line">    fn.tid = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.call(context);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>作用域安全的构建函数，针对没有使用 <code>new</code> 实例化的构建函数，使用  <code>instanceof</code> 检查 <code>this</code> 并做处理</li>
</ul>
<h3 id="执行上下文与作用域链">执行上下文与作用域链</h3><p>每个执行上下文（execution context）与一个作用域链（scope chain）关联，并且与其关联的作用域链只会被 with 语句和 catch 子句影响。<strong>进入一个函数，将从当前上下文进入一个新的执行上下文</strong>。创建执行上下文的过程如下：</p>
<ol>
<li><p>创建激活对象<br> 激活对象是在进入新的执行上下文时被创建出来的，与新的执行上下文关联。在初始化构造函数时，该对象包含一个名为 <code>arguments</code> 的属性。激活对象在变量初始化过程中会被用到。Javascript 代码不能直接访问该对象，但可以访问改对象的成员（如 <code>arguments</code>） </p>
</li>
<li><p>创建作用域链<br> 每一个 function 都有一个内部属性 <code>[[scope]]</code>，它的值是一个包含多个对象的链。创建作用域链主要是将上一步的激活对象添加到 function 的 <code>[[scope]]</code> 属性对象的链的前面</p>
</li>
<li><p>变量初始化<br> 对 function 所需的变量进行初始化。初始化时使用的对象是第一步创建的激活对象，此时称为变量对象。初始化的变量包括 function 调用时传入的实际参数、内部 function 和局部变量。</p>
</li>
</ol>
<p><strong>补充：</strong><br>此过程属于 javascript 对函数的预编译过程，详细可参见编译运行原理笔记</p>
<h3 id="执行函数">执行函数</h3><ul>
<li>形参被创建为变量对象的命名属性，如果调用函数时传递的参数与形参一致，则将参数的值赋值给这些命名属性，否则为 <code>undefined</code>；</li>
<li>局部变量只是在变量对象中创建了同名属性，值为 <code>undefined</code>，执行过程中才会被赋值；</li>
<li>内部定义函数（非嵌套函数）会以其声明时所用名称创建同名属性，对应的函数被创建为函数对象，并将其赋值给该属性（<strong>先预声明变量，再预定义函数</strong>）；</li>
<li>由于 <code>arguments</code> 属性与函数局部变量对应的命名属性都属于同一个调用对象，因此可以将 <code>arguments</code> 作为函数的局部变量看待</li>
<li>最后，创建 this 对象并对其进行赋值。如果赋值是一个对象，则指向该对象的引用；否则指向全局对象</li>
<li>执行函数结构体内语句</li>
<li><p>返回函数返回值</p>
<p>  全局 Javascript 代码是在全局执行上下文中运行的，该上下文的作用域链只包含一个全局对象</p>
</li>
</ul>
<h2 id="面向对象编程">面向对象编程</h2><ul>
<li><strong>对象（Object）没有原型</strong>，只有构造函数拥有原型，而构造类的实例对象都能通过 <code>protoype</code> 属性访问原型对象。构造函数的 <code>prototype</code> 属性存储着一个引用对象的指针，该指针指向一个原型对象，内部存储着构造函数的原始属性和方法，借助 <code>prototype</code> 属性可以访问原型对象内部成员。构造函数的实例对象可以访问构造函数的原型成员</li>
<li>检索原型链的过程称为原型委托</li>
<li><code>hasOwnProperty</code> 不会检查原型链</li>
<li>Javascript 中类似指针特性的标志符<ul>
<li><code>this</code> ，动态指针，利用 <code>call</code> 或 <code>apply</code> 可被转换为静态指针</li>
<li><code>callee</code> ，函数的参数集合包含的一个静态指针，始终指向参数集合所属的函数</li>
<li><code>prototype</code> ，函数包含的一个半静态指针,默认情况下指向函数指向的原型对象，可被修改</li>
<li><code>constructor</code> ，对象包含的指针，指向创建该对象的构造函数</li>
</ul>
</li>
<li><p>类继承，将父类的原型保存到子类中，实现方法覆盖</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    A.apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包实现的单例模式可作为静态类使用（建议100关于类的静态成员的示例中将公共方法绑定到 window，理解不能）</p>
</li>
<li><p>享元类，是创建类的类。其操作的对象是类，而不是具体的数据。一般享元类返回的类型是类。当类返回引用类型或函数体，则类的成员将不可访问（此处的示例代码让人疑惑）</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处引用原文示例</span></span><br><span class="line"><span class="comment">// f.x === undefined</span></span><br><span class="line"><span class="comment">// this.x 除非通过 that 否则无法访问，原因在于 F 的调用对象丢失？</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>掺元类（mixin），可通过原型继承实现</p>
</li>
</ul>
<h2 id="DOM编程">DOM编程</h2><ul>
<li>空格和换行符会被 DOM 作为一个节点解析</li>
<li>浏览器解析页面并创建两个内部数据结构，DOM树（表示页面结构）和渲染树（表示DOM节点如何显示）。</li>
<li>改变布局信息（<code>offsetTop</code>、<code>scrollTop</code>、<code>clientTop</code>等）会立即刷新渲染列表，即使部分浏览器通过队列化修改和批量显示来优化重拍版过程</li>
<li>工人线程 <code>Worker</code></li>
</ul>
<h2 id="客户端编程">客户端编程</h2><ul>
<li>浏览器在默认情况下使用冒泡型事件流，可显式设置并使用捕获型事件流。除了元素能够响应事件外，DOM 标准还规定文本节点也可以响应时间，但 IE 并不支持响应事件（不懂）</li>
<li>解析 <code>scrollHeight</code> 和 <code>scrollWidth</code> 属性</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">浏览器</th>
<th style="text-align:left">计算公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IE</td>
<td style="text-align:left"><code>padding</code> + 高度</td>
</tr>
<tr>
<td style="text-align:center">FireFox</td>
<td style="text-align:left"><code>padding-top</code> + 高度</td>
</tr>
<tr>
<td style="text-align:center">Opera</td>
<td style="text-align:left">高度 + 底部滚动条高度</td>
</tr>
<tr>
<td style="text-align:center">Safari</td>
<td style="text-align:left"><code>padding-top</code> + 高度</td>
</tr>
</tbody>
</table>
<ul>
<li>解析 <code>clientHeight</code> 和 <code>clientWidth</code> 属性</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">浏览器</th>
<th style="text-align:left">计算公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IE</td>
<td style="text-align:left"><code>padding</code> + 高度</td>
</tr>
<tr>
<td style="text-align:center">FireFox</td>
<td style="text-align:left"><code>padding</code> + <code>border</code> + 高度</td>
</tr>
<tr>
<td style="text-align:center">Opera</td>
<td style="text-align:left"><code>padding</code> + 高度</td>
</tr>
<tr>
<td style="text-align:center">Safari</td>
<td style="text-align:left"><code>padding</code> + 高度</td>
</tr>
</tbody>
</table>
<ul>
<li><code>&lt;html&gt;</code> 在DOM中表示为 <code>document.documentElement</code>，获取窗口大小可通过如下方法</li>
<li>获取绝对位置可通过 <code>offsetParent</code> 遍历实现，但是无法处理元素的边框</li>
</ul>
<h2 id="数据交互与储存">数据交互与储存</h2><ul>
<li>JSONP（json with padding）异步通信协议，默认以 <code>jsonp</code> 作为参数名指定回调函数</li>
<li>Multipart XHR ，可通过检验 <code>readyState ＝ 3</code> 并载入已经加载的图片或者代码。缺点是无法被服务器缓存，IE8 才开始支持 <code>readyState ＝ 3</code> 和 <code>data:URL</code></li>
<li>使用 XHR 将数据发回服务器比使用 GET 快，因为向服务器发送一个 GET 请求要占用一个单独的数据包。另外，一个 POST 请求至少发送两个数据包，一个用于信息头，另一个用于 POST 体。POST 适合向服务器发送大量数据，因为它既不关心额外数据包的数量，也没有 IE 的 URL 长度限制</li>
<li>使用数组格式压缩 json，牺牲了可读性</li>
<li><code>split()</code> 是最快的字符串操作之一</li>
<li>XSS（ Cross Site Script ）<ul>
<li>反射型：请求数据在服务响应页面中呈现为未编码和未过滤，通过 URL 注入</li>
<li>持久型：包含恶意代码的请求数据被保存在 Web 应用的服务器上，每次用户访问某个页面时恶意代码会被执行</li>
</ul>
</li>
<li>XSS 防范<ul>
<li>不要信任用户的人和输入，采用白名单技术验证输入参数</li>
<li>输出的时候对用户提供的内容进行转义处理</li>
</ul>
</li>
<li>Javascript 挟持。攻击者在恶意站点的页面中通过 <code>&lt;script&gt;</code> 标签调用被攻击站点的一个 JSON 动态数据接口，并通过 Javascript Function Hook 等技术取得这些 JSON 数据。具体是用户在登陆被攻击站点后，访问恶意站点。假设其身份认证基于 Session Cookie 来保存，则恶意站点发送的请求被认为是合法的。整个过程相当于一个站外类型的跨站点请求伪造（CSRF）攻击</li>
</ul>
<h2 id="JavaScript_引擎与兼容性">JavaScript 引擎与兼容性</h2><ul>
<li>UA 检验系统，包括 “Win”, “Mac”, “X11”</li>
<li>IE 初始化数组</li>
<li><p>在 IE 中函数表达式中的标志符在闭包的上下文环境是可见的，因为表达式函数被视为闭包内的函数声明，而其他浏览器将报错</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        foo(<span class="literal">false</span>);	<span class="comment">// IE 中可正常执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>IE 和 Opera 中，<code>with</code> 中使用函数声明定义一个函数时，函数作用域绑定到全局作用域，而与 <code>with</code> 的运算值无关。使用函数表达式定义表现正常</p>
</li>
<li>IE 不允许通过 <code>for in</code> 属性枚举类型的自定义属性（不清楚）</li>
<li>IE 中，用于捕获异常的变量在当前上下文环境是可见的，在 <code>catch</code> 字句执行完毕之后变量依然存在，但在该上下文环境被注销后会消失</li>
<li>IE 中，<code>Array.prototype.join</code> 在缺少参数时会将 <code>undefined</code> 作为分隔符</li>
<li>IE 中，<code>Array.prototype.unshift</code> 返回 <code>undefined</code> 而不是数组长度</li>
<li>IE 中，调用日期原型的 <code>valueOf</code> 方法返回 0，而标准规定 <code>NaN</code></li>
<li>IE 中，<code>getYear</code> 类似于 <code>getFullYear</code></li>
<li>IE 中，<code>typeof window.alert === object</code>，同时 <code>(a = widnow.alert).call(null, 1)</code> 将报错</li>
<li>IE 中，使用最后一次出现的函数声明定义函数，无视 <code>if else</code></li>
<li>EMCAScript v3 规范不允许其他变量间接调用全局函数 <code>eval()</code>，否则抛出 EvalError 异常，但 IE、FF、Safari 引擎允许间接调用 <code>eval()</code></li>
<li><code>parseInt()</code> 方法当基数为 0 时，IE 和 FF、Safari 引擎会把它解析为八进制数字， Chrome 不会</li>
<li>不同引擎对各种 <code>toString</code> 方法的返回值不同</li>
<li>IE 和 Opera 会把字符串带符号的十六进制数字转换为 NaN，而其他引擎会把它转换为负数</li>
<li>IE9 以下， <code>event.srcElement</code> 相当于 <code>event.target</code>，但是前者返回 <code>HTML Element</code>，后者返回节点，包括文本节点</li>
<li>IE 中使用 <code>event.keyCode</code> 获取键盘值，其他浏览器使用 <code>event.which</code></li>
<li>鼠标位置</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">浏览器</th>
<th style="text-align:center">绝对位置</th>
<th style="text-align:center">相对位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IE</td>
<td style="text-align:center">event.x (event.clientX)<br>event.y (event.clientY)</td>
<td style="text-align:center">event.offsetX<br>event.offsetY</td>
</tr>
<tr>
<td style="text-align:center">非IE</td>
<td style="text-align:center">event.PageX<br>event.PageY</td>
<td style="text-align:center">event.layerX<br>event.layerY</td>
</tr>
</tbody>
</table>
<ul>
<li>IE 中，<code>input.type</code> 为只读属性，其他浏览器为读 / 写</li>
<li>IE 中，使用 <code>currentStyle</code> 获取样式，其他浏览器使用 <code>getComputedStyle</code></li>
<li>IE 通过 <code>htmlFor</code> 访问标签 <code>for</code> 属性</li>
</ul>
<h2 id="Javascript编程规范和应用">Javascript编程规范和应用</h2><ul>
<li>Javascript 按代码块预编译和执行</li>
<li>避免二次评估，即避免使用 <code>eval</code>，<code>new Function()</code> 编译执行代码，包括 <code>setTimeout</code>，<code>setInterval</code></li>
<li>使用直接量赋值更快</li>
<li><p>使用位操作符执行逻辑运算</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> &amp; <span class="number">3</span> === <span class="number">0</span></span><br><span class="line"><span class="number">11</span> &amp; <span class="number">1</span> === <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;script&gt;</code> 的 defer 属性只适用于 IE 和 FF 3.5以上</p>
</li>
<li>IE 不支持 <code>&lt;script&gt;</code> 标签的 <code>onload</code> 事件，但实现了 <code>readyState</code> 属性</li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>uninitialized</td>
<td>默认状态</td>
</tr>
<tr>
<td>loading</td>
<td>下载开始</td>
</tr>
<tr>
<td>loaded</td>
<td>下载完成</td>
</tr>
<tr>
<td>interactive</td>
<td>下载完成但不可用</td>
</tr>
<tr>
<td>complete</td>
<td>所有数据准备完成</td>
</tr>
</tbody>
</table>
<ul>
<li>HTMLCollection 对象并不是一个固定的值，而是一个动态的结果</li>
<li>通过 <code>setTimeout</code> 拆分任务</li>
<li>Web Worker</li>
<li>Javascript 是一种垃圾收集式语言，其对象的内存是根据对象的创建分配给该对象，并且会在没有对该对象引用时由浏览器回收</li>
<li>两个对象相互应用会造成内存泄漏，常见于闭包内的 DOM 对象</li>
<li>HTML 中的 <code>&lt;script&gt;</code> 标签内的 Javascript 代码被解释为 CDATA（Character Data，XML 中的一种类型，用于包含任意的字符数据）</li>
<li><p>使 XML 的语法校验器忽视这段内容，同时利用注释使代码能够被 Javascript 引擎识别</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">/* <span class="cdata">&lt;![CDATA[ */ 插入 Javascript 代码 /* ]]&gt;</span>*/</span><br></pre></td></tr></table></figure>
</li>
<li><p>旧浏览器使用局部变量减少对象成员访问</p>
</li>
<li>不同浏览器对长时间运行脚本的检测方法不同，基于时间或指令数量</li>
</ul>
<h6 id="小记：看了前面一部分，感觉很多都在语言精粹里面看过了，甚至文字的表述都让人很熟悉；正则表达式看到了一些新的东西，还没系统学习过所以就快速过了，回头必须补上；函数一章的内容多次刷新了自己对于作用域和上下文的理解，对于如何创建一个函数有刨根问底的解释，感觉要看多几次才能消化；然后渐渐发现书本中很多描述重复出现；数据交互与储存一章对_JOSNP_的描述以及后部分提到的_XSS_攻击方法很清晰；js_引擎实现与规范一章很粗糙的描述了不同浏览器引擎的兼容问题，忽略了浏览器更新修复支持的情况，导致这部分内容很糟糕。尽管存在一些问题，但这本书还是很值得购入认真看一遍，收获很多">小记：看了前面一部分，感觉很多都在语言精粹里面看过了，甚至文字的表述都让人很熟悉；正则表达式看到了一些新的东西，还没系统学习过所以就快速过了，回头必须补上；函数一章的内容多次刷新了自己对于作用域和上下文的理解，对于如何创建一个函数有刨根问底的解释，感觉要看多几次才能消化；然后渐渐发现书本中很多描述重复出现；数据交互与储存一章对 JOSNP 的描述以及后部分提到的 XSS 攻击方法很清晰；js 引擎实现与规范一章很粗糙的描述了不同浏览器引擎的兼容问题，忽略了浏览器更新修复支持的情况，导致这部分内容很糟糕。尽管存在一些问题，但这本书还是很值得购入认真看一遍，收获很多</h6>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/07/cigq75fqi000x6xqcpj5idqet/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          关于apply和call
        
      </div>
    </a>
  
  
    <a href="/2015/06/cigq75fpf00006xqcu4gj0xmp/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Javascript设计模式</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 liyh
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-67000695-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>